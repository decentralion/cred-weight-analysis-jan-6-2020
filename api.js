(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else {
		var a = factory();
		for(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];
	}
})(global, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/api/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/analysis/pluginDeclaration.js":
/*!*******************************************!*\
  !*** ./src/analysis/pluginDeclaration.js ***!
  \*******************************************/
/*! exports provided: combineTypes */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"combineTypes\", function() { return combineTypes; });\n// TODO(@decentralion): Maybe merge this file with analysis/types\nfunction combineTypes(decs){const nodeTypes=[].concat(...decs.map(x=>x.nodeTypes));const edgeTypes=[].concat(...decs.map(x=>x.edgeTypes));return{nodeTypes,edgeTypes};}\n\n//# sourceURL=webpack:///./src/analysis/pluginDeclaration.js?");

/***/ }),

/***/ "./src/analysis/timeline/distributionToCred.js":
/*!*****************************************************!*\
  !*** ./src/analysis/timeline/distributionToCred.js ***!
  \*****************************************************/
/*! exports provided: distributionToCred */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"distributionToCred\", function() { return distributionToCred; });\n/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-array */ \"d3-array\");\n/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(d3_array__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _core_graph__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../core/graph */ \"./src/core/graph.js\");\n/**\n * Takes timeline distributions and uses them to create normalized cred.\n *//**\n * Represents the full timeline cred for a graph.\n */ /**\n * Convert a TimelineDistribution into TimelineCred.\n *\n * The difference between the distribution and cred is that cred has been\n * re-normalized to present human-agreeable scores, rather than a probability\n * distribution.\n *\n * This implementation normalizes the scores so that in each interval, the\n * total score of every node matching scoringNodePrefix is equal to the\n * interval's weight.\n */function distributionToCred(ds,nodeOrder,scoringNodePrefixes){if(ds.length===0){return[];}const intervals=ds.map(x=>x.interval);const scoringNodeIndices=[];const cred=new Array(nodeOrder.length);for(let i=0;i<nodeOrder.length;i++){const addr=nodeOrder[i];if(scoringNodePrefixes.some(x=>_core_graph__WEBPACK_IMPORTED_MODULE_1__[\"NodeAddress\"].hasPrefix(addr,x))){scoringNodeIndices.push(i);}cred[i]=new Array(intervals.length);}if(scoringNodeIndices.length===0){throw new Error(\"no nodes matched scoringNodePrefix\");}return ds.map((_ref)=>{let{interval,distribution,intervalWeight}=_ref;const intervalTotalScore=Object(d3_array__WEBPACK_IMPORTED_MODULE_0__[\"sum\"])(scoringNodeIndices.map(x=>distribution[x]));const intervalNormalizer=intervalWeight/intervalTotalScore;const cred=distribution.map(x=>x*intervalNormalizer);return{interval,cred};});}\n\n//# sourceURL=webpack:///./src/analysis/timeline/distributionToCred.js?");

/***/ }),

/***/ "./src/analysis/timeline/interval.js":
/*!*******************************************!*\
  !*** ./src/analysis/timeline/interval.js ***!
  \*******************************************/
/*! exports provided: partitionGraph, graphIntervals, weekIntervals */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"partitionGraph\", function() { return partitionGraph; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"graphIntervals\", function() { return graphIntervals; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"weekIntervals\", function() { return weekIntervals; });\n/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-array */ \"d3-array\");\n/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(d3_array__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var lodash_sortby__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lodash.sortby */ \"lodash.sortby\");\n/* harmony import */ var lodash_sortby__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(lodash_sortby__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var d3_time__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-time */ \"d3-time\");\n/* harmony import */ var d3_time__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(d3_time__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _util_null__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../util/null */ \"./src/util/null.js\");\n/**\n * Partition a graph based on time intervals.\n *\n * The intervals are always one week long, as calculated using d3.utcWeek.\n * The result may contain empty intervals.\n * If the graph is empty, no intervals are returned.\n * Timeless nodes are not included in the partition, nor are dangling edges.\n */function partitionGraph(graph){const nodes=Array.from(graph.nodes());const timefulNodes=nodes.filter(x=>x.timestampMs!=null);const sortedNodes=lodash_sortby__WEBPACK_IMPORTED_MODULE_1___default()(timefulNodes,x=>x.timestampMs);const edges=Array.from(graph.edges({showDangling:false}));const sortedEdges=lodash_sortby__WEBPACK_IMPORTED_MODULE_1___default()(edges,x=>x.timestampMs);const intervals=graphIntervals(graph);let nodeIndex=0;let edgeIndex=0;return intervals.map(interval=>{const nodes=[];const edges=[];while(nodeIndex<sortedNodes.length&&sortedNodes[nodeIndex].timestampMs<interval.endTimeMs){nodes.push(sortedNodes[nodeIndex++]);}while(edgeIndex<sortedEdges.length&&sortedEdges[edgeIndex].timestampMs<interval.endTimeMs){edges.push(sortedEdges[edgeIndex++]);}return{interval,nodes,edges};});}/**\n * Produce an array of Intervals which cover all the node and edge timestamps\n * for a graph.\n *\n * The intervals are one week long, and are aligned on clean week boundaries.\n *\n * This function is basically a wrapper around weekIntervals that makes sure\n * the graph's nodes and edges are all accounted for properly.\n */function graphIntervals(graph){const nodeTimestamps=Array.from(graph.nodes()).map(x=>x.timestampMs).filter(x=>x!=null)// Unnecessary map is to satisfy flow that the array doesn't contain null.\n.map(x=>_util_null__WEBPACK_IMPORTED_MODULE_3__[\"get\"](x));const edgeTimestamps=Array.from(graph.edges({showDangling:false})).map(x=>x.timestampMs);if(nodeTimestamps.length===0&&edgeTimestamps.length===0){return[];}const allTimestamps=nodeTimestamps.concat(edgeTimestamps);const start=Object(d3_array__WEBPACK_IMPORTED_MODULE_0__[\"min\"])(allTimestamps);const end=Object(d3_array__WEBPACK_IMPORTED_MODULE_0__[\"max\"])(allTimestamps);return weekIntervals(start,end);}/**\n * Produce an array of week-long intervals to cover the startTime and endTime.\n *\n * Each interval is one week long and aligned on week boundaries, as produced\n * by d3.utcWeek. The weeks always use UTC boundaries to ensure consistent\n * output regardless of which timezone the user is in.\n *\n * Assuming that the inputs are valid, there will always be at least one\n * interval, so that that interval can cover the input timestamps. (E.g. if\n * startMs and endMs are the same value, then the produced interval will be the\n * start and end of the last week that starts on or before startMs.)\n */function weekIntervals(startMs,endMs){if(!isFinite(startMs)||!isFinite(endMs)){throw new Error(\"invalid non-finite input\");}if(typeof startMs!==\"number\"||typeof endMs!==\"number\"){throw new Error(\"start or end are not numbers\");}if(startMs>endMs){throw new Error(\"start time after end time\");}// Promote the window to the nearest week boundaries, to ensure that\n// utcWeek.range will not return an empty array.\n// We add one to the endTime so that just in case we're exactly on a week\n// boundary, we still get at least one interval.\nstartMs=d3_time__WEBPACK_IMPORTED_MODULE_2__[\"utcWeek\"].floor(startMs);endMs=d3_time__WEBPACK_IMPORTED_MODULE_2__[\"utcWeek\"].ceil(endMs+1);const boundaries=d3_time__WEBPACK_IMPORTED_MODULE_2__[\"utcWeek\"].range(startMs,endMs);boundaries.push(endMs);const intervals=[];for(let i=0;i<boundaries.length-1;i++){intervals.push({startTimeMs:+boundaries[i],endTimeMs:+boundaries[i+1]});}return intervals;}\n\n//# sourceURL=webpack:///./src/analysis/timeline/interval.js?");

/***/ }),

/***/ "./src/analysis/timeline/params.js":
/*!*****************************************!*\
  !*** ./src/analysis/timeline/params.js ***!
  \*****************************************/
/*! exports provided: DEFAULT_ALPHA, DEFAULT_INTERVAL_DECAY, paramsToJSON, paramsFromJSON, defaultParams, partialParams */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DEFAULT_ALPHA\", function() { return DEFAULT_ALPHA; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DEFAULT_INTERVAL_DECAY\", function() { return DEFAULT_INTERVAL_DECAY; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"paramsToJSON\", function() { return paramsToJSON; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"paramsFromJSON\", function() { return paramsFromJSON; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"defaultParams\", function() { return defaultParams; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"partialParams\", function() { return partialParams; });\n/* harmony import */ var _weights__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../weights */ \"./src/analysis/weights.js\");\nfunction ownKeys(object,enumerableOnly){var keys=Object.keys(object);if(Object.getOwnPropertySymbols){var symbols=Object.getOwnPropertySymbols(object);if(enumerableOnly)symbols=symbols.filter(function(sym){return Object.getOwnPropertyDescriptor(object,sym).enumerable;});keys.push.apply(keys,symbols);}return keys;}function _objectSpread(target){for(var i=1;i<arguments.length;i++){var source=arguments[i]!=null?arguments[i]:{};if(i%2){ownKeys(Object(source),true).forEach(function(key){_defineProperty(target,key,source[key]);});}else if(Object.getOwnPropertyDescriptors){Object.defineProperties(target,Object.getOwnPropertyDescriptors(source));}else{ownKeys(Object(source)).forEach(function(key){Object.defineProperty(target,key,Object.getOwnPropertyDescriptor(source,key));});}}return target;}function _defineProperty(obj,key,value){if(key in obj){Object.defineProperty(obj,key,{value:value,enumerable:true,configurable:true,writable:true});}else{obj[key]=value;}return obj;}/**\n * Parameters for computing TimelineCred\n *\n * The parameters are intended to be user-configurable.\n */const DEFAULT_ALPHA=0.2;const DEFAULT_INTERVAL_DECAY=0.5;function paramsToJSON(p){return{alpha:p.alpha,intervalDecay:p.intervalDecay,weights:Object(_weights__WEBPACK_IMPORTED_MODULE_0__[\"toJSON\"])(p.weights)};}function paramsFromJSON(p){return{alpha:p.alpha,intervalDecay:p.intervalDecay,weights:Object(_weights__WEBPACK_IMPORTED_MODULE_0__[\"fromJSON\"])(p.weights)};}/**\n * Exports the default TimelineCredParameters.\n *\n * End consumers of SourceCred will not need to depend on this; it's\n * provided for implementation of SourceCred's APIs.\n */function defaultParams(){return{alpha:DEFAULT_ALPHA,intervalDecay:DEFAULT_INTERVAL_DECAY,weights:Object(_weights__WEBPACK_IMPORTED_MODULE_0__[\"defaultWeights\"])()};}/**\n * Fill in default values for timeline cred parameters.\n */function partialParams(partial){return _objectSpread({},defaultParams(),{},partial);}\n\n//# sourceURL=webpack:///./src/analysis/timeline/params.js?");

/***/ }),

/***/ "./src/analysis/timeline/timelineCred.js":
/*!***********************************************!*\
  !*** ./src/analysis/timeline/timelineCred.js ***!
  \***********************************************/
/*! exports provided: TimelineCred */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TimelineCred\", function() { return TimelineCred; });\n/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-array */ \"d3-array\");\n/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(d3_array__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var lodash_sortby__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lodash.sortby */ \"lodash.sortby\");\n/* harmony import */ var lodash_sortby__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(lodash_sortby__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _util_null__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../util/null */ \"./src/util/null.js\");\n/* harmony import */ var _util_map__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../util/map */ \"./src/util/map.js\");\n/* harmony import */ var _util_compat__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../util/compat */ \"./src/util/compat.js\");\n/* harmony import */ var _timelinePagerank__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./timelinePagerank */ \"./src/analysis/timeline/timelinePagerank.js\");\n/* harmony import */ var _distributionToCred__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./distributionToCred */ \"./src/analysis/timeline/distributionToCred.js\");\n/* harmony import */ var _pluginDeclaration__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../pluginDeclaration */ \"./src/analysis/pluginDeclaration.js\");\n/* harmony import */ var _core_graph__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../core/graph */ \"./src/core/graph.js\");\n/* harmony import */ var _params__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./params */ \"./src/analysis/timeline/params.js\");\nfunction _defineProperty(obj,key,value){if(key in obj){Object.defineProperty(obj,key,{value:value,enumerable:true,configurable:true,writable:true});}else{obj[key]=value;}return obj;}/**\n * Represents the timeline cred of a graph. This class wraps all the data\n * needed to analyze and interpet cred (ie. it has the Graph and the cred\n * scores), and provides convenient view methods for accessing the cred.\n *\n * The TimelineCred also has the params and config. The intention is that this\n * is a \"one stop shop\" for serializing SourceCred results.\n */class TimelineCred{constructor(graph,intervals,addressToCred,params,plugins){_defineProperty(this,\"_graph\",void 0);_defineProperty(this,\"_intervals\",void 0);_defineProperty(this,\"_addressToCred\",void 0);_defineProperty(this,\"_params\",void 0);_defineProperty(this,\"_plugins\",void 0);this._graph=graph;this._intervals=intervals;this._addressToCred=addressToCred;this._params=params;this._plugins=plugins;}graph(){return this._graph;}params(){return this._params;}plugins(){return this._plugins;}/**\n   * Creates a new TimelineCred based on the new Parameters.\n   * Holds the graph and config constant.\n   *\n   * This returns a new TimelineCred; it does not modify the existing one.\n   */async reanalyze(newParams){return await TimelineCred.compute({graph:this._graph,params:newParams,plugins:this._plugins});}/**\n   * Return all the intervals in the timeline.\n   */intervals(){return this._intervals;}/**\n   * Get the CredNode for a given NodeAddress.\n   *\n   * Returns undefined if the node is not in the filtered results.\n   *\n   * Note that it's possible that the node is present in the Graph, but not the\n   * filtered results; if so, it will return undefined.\n   */credNode(a){const cred=this._addressToCred.get(a);if(cred===undefined){return undefined;}const total=Object(d3_array__WEBPACK_IMPORTED_MODULE_0__[\"sum\"])(cred);const node=_util_null__WEBPACK_IMPORTED_MODULE_2__[\"get\"](this._graph.node(a));return{cred,total,node};}/**\n   * Returns nodes sorted by their total cred (descending).\n   *\n   * If prefixes is provided, then only nodes matching at least one of the provided\n   * address prefixes will be included.\n   */credSortedNodes(prefixes){let addresses=Array.from(this._addressToCred.keys());if(prefixes!=null){const match=a=>prefixes.some(p=>_core_graph__WEBPACK_IMPORTED_MODULE_8__[\"NodeAddress\"].hasPrefix(a,p));addresses=addresses.filter(match);}const credNodes=addresses.map(a=>this.credNode(a));return lodash_sortby__WEBPACK_IMPORTED_MODULE_1___default()(credNodes,x=>-x.total);}/**\n   * Returns all user-typed nodes, sorted by their total cred (descending).\n   *\n   * A node is considered a user-type node if its address has a prefix match\n   * with a type specified as a user type by one of the plugin declarations.\n   */userNodes(){const userTypes=[].concat(...this.plugins().map(p=>p.userTypes));return this.credSortedNodes(userTypes.map(x=>x.prefix));}/**\n   * Create a new, filtered TimelineCred, by removing low-scored nodes.\n   *\n   * Cred Graphs may have a huge number of small contributions, like comments,\n   * in which end users are not particularly interested. However, the size of\n   * the TimelineCred offered to the frontend matters quite a bit. Therefore,\n   * we can use this method to discard almost all nodes in the graph.\n   *\n   * Specifically, `reduceSize` takes in an array of inclusion prefixes: for\n   * each inclusion prefix, we will take the top `k` nodes matching that prefix\n   * (by total score across all intervals).\n   *\n   * It also takes `fullInclusion` prefixes: for these prefixes, every matching\n   * node will be included. This allows us to ensure that e.g. every user will\n   * be included in the `cli scores` output, even if they are not in the top\n   * `k` users.\n   */reduceSize(opts){const{typePrefixes,nodesPerType,fullInclusionPrefixes}=opts;const selectedNodes=new Set();for(const prefix of typePrefixes){const matchingNodes=this.credSortedNodes([prefix]).slice(0,nodesPerType);for(const{node}of matchingNodes){selectedNodes.add(node.address);}}// For the fullInclusionPrefixes, we won't slice -- we just take every match.\nconst matchingNodes=this.credSortedNodes(fullInclusionPrefixes);for(const{node}of matchingNodes){selectedNodes.add(node.address);}const filteredAddressToCred=new Map();for(const address of selectedNodes){const cred=_util_null__WEBPACK_IMPORTED_MODULE_2__[\"get\"](this._addressToCred.get(address));filteredAddressToCred.set(address,cred);}return new TimelineCred(this._graph,this._intervals,filteredAddressToCred,this._params,this._plugins);}toJSON(){const rawJSON={graphJSON:this._graph.toJSON(),intervalsJSON:this._intervals,credJSON:_util_map__WEBPACK_IMPORTED_MODULE_3__[\"toObject\"](this._addressToCred),paramsJSON:Object(_params__WEBPACK_IMPORTED_MODULE_9__[\"paramsToJSON\"])(this._params),pluginsJSON:this._plugins};return Object(_util_compat__WEBPACK_IMPORTED_MODULE_4__[\"toCompat\"])(COMPAT_INFO,rawJSON);}static fromJSON(j){const json=Object(_util_compat__WEBPACK_IMPORTED_MODULE_4__[\"fromCompat\"])(COMPAT_INFO,j);const{graphJSON,intervalsJSON,credJSON,paramsJSON,pluginsJSON}=json;const cred=_util_map__WEBPACK_IMPORTED_MODULE_3__[\"fromObject\"](credJSON);const graph=_core_graph__WEBPACK_IMPORTED_MODULE_8__[\"Graph\"].fromJSON(graphJSON);const params=Object(_params__WEBPACK_IMPORTED_MODULE_9__[\"paramsFromJSON\"])(paramsJSON);return new TimelineCred(graph,intervalsJSON,cred,params,pluginsJSON);}static async compute(opts){const{graph,params,plugins}=opts;const fullParams=params==null?Object(_params__WEBPACK_IMPORTED_MODULE_9__[\"defaultParams\"])():Object(_params__WEBPACK_IMPORTED_MODULE_9__[\"partialParams\"])(params);const nodeOrder=Array.from(graph.nodes()).map(x=>x.address);const types=Object(_pluginDeclaration__WEBPACK_IMPORTED_MODULE_7__[\"combineTypes\"])(plugins);const userTypes=[].concat(...plugins.map(x=>x.userTypes));const scorePrefixes=userTypes.map(x=>x.prefix);const distribution=await Object(_timelinePagerank__WEBPACK_IMPORTED_MODULE_5__[\"timelinePagerank\"])(graph,types,fullParams.weights,fullParams.intervalDecay,fullParams.alpha);const cred=Object(_distributionToCred__WEBPACK_IMPORTED_MODULE_6__[\"distributionToCred\"])(distribution,nodeOrder,userTypes.map(x=>x.prefix));const addressToCred=new Map();for(let i=0;i<nodeOrder.length;i++){const addr=nodeOrder[i];const addrCred=cred.map((_ref)=>{let{cred}=_ref;return cred[i];});addressToCred.set(addr,addrCred);}const intervals=cred.map(x=>x.interval);const preliminaryCred=new TimelineCred(graph,intervals,addressToCred,fullParams,plugins);return preliminaryCred.reduceSize({typePrefixes:types.nodeTypes.map(x=>x.prefix),nodesPerType:100,fullInclusionPrefixes:scorePrefixes});}}const COMPAT_INFO={type:\"sourcecred/timelineCred\",version:\"0.5.0\"};\n\n//# sourceURL=webpack:///./src/analysis/timeline/timelineCred.js?");

/***/ }),

/***/ "./src/analysis/timeline/timelinePagerank.js":
/*!***************************************************!*\
  !*** ./src/analysis/timeline/timelinePagerank.js ***!
  \***************************************************/
/*! exports provided: timelinePagerank, _timelineNodeWeights, _timelineMarkovChain, _computeTimelineDistribution */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"timelinePagerank\", function() { return timelinePagerank; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"_timelineNodeWeights\", function() { return _timelineNodeWeights; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"_timelineMarkovChain\", function() { return _timelineMarkovChain; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"_computeTimelineDistribution\", function() { return _computeTimelineDistribution; });\n/* harmony import */ var deep_freeze__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! deep-freeze */ \"deep-freeze\");\n/* harmony import */ var deep_freeze__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(deep_freeze__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-array */ \"d3-array\");\n/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(d3_array__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _util_null__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../util/null */ \"./src/util/null.js\");\n/* harmony import */ var _core_graph__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../core/graph */ \"./src/core/graph.js\");\n/* harmony import */ var _interval__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./interval */ \"./src/analysis/timeline/interval.js\");\n/* harmony import */ var _weightEvaluator__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../weightEvaluator */ \"./src/analysis/weightEvaluator.js\");\n/* harmony import */ var _core_attribution_nodeDistribution__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../core/attribution/nodeDistribution */ \"./src/core/attribution/nodeDistribution.js\");\n/* harmony import */ var _core_attribution_graphToMarkovChain__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../core/attribution/graphToMarkovChain */ \"./src/core/attribution/graphToMarkovChain.js\");\n/* harmony import */ var _core_attribution_markovChain__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../core/attribution/markovChain */ \"./src/core/attribution/markovChain.js\");\n/**\n * Core logic for computing timeline PageRank on a graph.\n *//**\n * Represents raw PageRank distributions on a graph over time.\n */ /**\n * Runs timeline PageRank on a graph.\n *\n * The graph is partitioned into weeklong intervals. For each interval, we run\n * PageRank, assigning seed weight to nodes which have already been created,\n * and considering edges which have already been created. Node weights and edge\n * weights both decay by the `intervalDecay` every week.\n *\n * Detailed description:\n *\n * First, we partition the graph into week-long intervals using the `interval`\n * module. For each such interval, we will produce a score distribution over\n * all the nodes in the graph, and a total weight for the interval, based on\n * the decayed weights of all the nodes that had been created as of that\n * interval.\n *\n * To get the score distribution, we create a node weight map for each\n * interval, and a markov chain for each interval.\n *\n * In the node weight map, every node is initially assigned full weight in the\n * interval of its creation, and in every interval thereafter its weight decays\n * by `intervalDecay`. However, note that the 'full weight' is normalized based\n * on the interval decay. To make this concrete, suppose that we have an\n * interval decay of 0.5, and a node with a base weight of 8. We want the total\n * weight given to this node (across all intervals) to equal 8, so that\n * weight-based cred normalization will be independent of the interval decay.\n * So we give it a normalized weight of 4 in the first interval, 2 in the\n * second, and so forth.\n *\n * For each interval, we also create a markov chain which describes the graph\n * state as of that interval. That markov chain only contains weight for edges\n * which were already created as of the interval; any edges that are not yet\n * created effectively have a weight of 0. Like the node weights, edge weights\n * are created with full weight, and then decay by `intervalDecay` each\n * interval. Unlike the node weights, we don't need to normalize based on\n * intervalDecay, since markov chains always normalize the edge weights.\n *\n * Given the markov chain and node weights for the interval, we compute the\n * score distribution by running finding the stationary distribution for that\n * markov chain, using the node weights as the seed vector. As ever, the\n * `alpha` parameter determines how much probability mass returns to the seed\n * vector. (See the docs in markovChain.js for more details.) The score\n * distribution uses the Graph's canonical node ordering.\n *\n * The output array contains an element for each interval in the graph\n * partitioning. Each element contains the interval, the distribution, as well\n * as the sum of all node weights for that interval (so that we can normalize\n * cred).\n *\n * The method is factored apart into a wrapper function which does validation,\n * and iterators that produce the node weights and the markov chains. This\n * facilitates testing the timelime logic separately. Finally, we compose all\n * the pieces and run PageRank for each interval.\n */async function timelinePagerank(graph,types,weights,intervalDecay,alpha){if(intervalDecay<0||intervalDecay>1||!isFinite(intervalDecay)){throw new Error(\"invalid intervalDecay: \".concat(intervalDecay));}if(alpha<0||alpha>1||!isFinite(alpha)){throw new Error(\"invalid alpha: \".concat(alpha));}// Produce the evaluators we will use to get the baseline weight for each\n// node and edge\nconst nodeEvaluator=Object(_weightEvaluator__WEBPACK_IMPORTED_MODULE_5__[\"nodeWeightEvaluator\"])(types.nodeTypes,weights);const edgeEvaluator=Object(_weightEvaluator__WEBPACK_IMPORTED_MODULE_5__[\"edgeWeightEvaluator\"])(types.edgeTypes,weights);const graphPartitionSlices=Object(_interval__WEBPACK_IMPORTED_MODULE_4__[\"partitionGraph\"])(graph);if(graphPartitionSlices.length===0){return[];}const intervals=graphPartitionSlices.map(x=>x.interval);const nodeCreationHistory=graphPartitionSlices.map(x=>x.nodes);const edgeCreationHistory=graphPartitionSlices.map(x=>x.edges);const nodeOrder=Array.from(graph.nodes()).map(x=>x.address);const nodeWeightIterator=_timelineNodeWeights(nodeCreationHistory,nodeEvaluator,intervalDecay);const markovChainIterator=_timelineMarkovChain(graph,edgeCreationHistory,edgeEvaluator,intervalDecay);return _computeTimelineDistribution(nodeOrder,intervals,nodeWeightIterator,markovChainIterator,alpha);}function*_timelineNodeWeights(nodeCreationHistory,nodeEvaluator,intervalDecay){let lastNodeWeights=new Map();for(const nodes of nodeCreationHistory){const nodeWeights=new Map();// Decay all the previous weights.\nfor(const[address,weight]of lastNodeWeights.entries()){nodeWeights.set(address,weight*intervalDecay);}// Add new nodes at full weight.\nfor(const{address}of nodes){// Normalize by (1 - intervalDecay) so that the total weight of a node across\n// intervals converges to the full base weight\nconst normalizedWeight=nodeEvaluator(address)*(1-intervalDecay);nodeWeights.set(address,normalizedWeight);}yield nodeWeights;lastNodeWeights=nodeWeights;}}function*_timelineMarkovChain(graph,edgeCreationHistory,edgeEvaluator,intervalDecay){const edgeWeights=new Map();for(const edges of edgeCreationHistory){for(const[address,{forwards,backwards}]of edgeWeights.entries()){edgeWeights.set(address,{forwards:forwards*intervalDecay,backwards:backwards*intervalDecay});}for(const{address}of edges){edgeWeights.set(address,edgeEvaluator(address));}const defaultEdgeWeight=deep_freeze__WEBPACK_IMPORTED_MODULE_0___default()({forwards:0,backwards:0});const currentEdgeWeight=e=>{return _util_null__WEBPACK_IMPORTED_MODULE_2__[\"orElse\"](edgeWeights.get(e.address),defaultEdgeWeight);};// Construct a new Markov chain corresponding to the current weights\n// of the edges.\n// TODO: Rather than constructing a markov chain from scratch, we can\n// update the markov chain in-place. This should result in a significant\n// performance improvement. We will need to change the markov chain\n// representation to do so (we should add a `totalOutWeight` array to the\n// chain, so that we can efficiently update the total weight as we add new\n// connections, rather than needing to re-normalize the whole chain for\n// each interval).\nconst chain=Object(_core_attribution_graphToMarkovChain__WEBPACK_IMPORTED_MODULE_7__[\"createOrderedSparseMarkovChain\"])(Object(_core_attribution_graphToMarkovChain__WEBPACK_IMPORTED_MODULE_7__[\"createConnections\"])(graph,currentEdgeWeight,1e-3)).chain;yield chain;}}// Warning: This function is untested.\n// Modify with care.\nasync function _computeTimelineDistribution(nodeOrder,intervals,nodeWeightIterator,markovChainIterator,alpha){const results=[];let pi0=null;for(const interval of intervals){const nodeWeights=_util_null__WEBPACK_IMPORTED_MODULE_2__[\"get\"](nodeWeightIterator.next().value);const chain=_util_null__WEBPACK_IMPORTED_MODULE_2__[\"get\"](markovChainIterator.next().value);const seed=Object(_core_attribution_nodeDistribution__WEBPACK_IMPORTED_MODULE_6__[\"weightedDistribution\"])(nodeOrder,nodeWeights);if(pi0==null){pi0=seed;}const params={chain,alpha,seed,pi0};const distributionResult=await Object(_core_attribution_markovChain__WEBPACK_IMPORTED_MODULE_8__[\"findStationaryDistribution\"])(params,{verbose:false,convergenceThreshold:1e-7,maxIterations:255,yieldAfterMs:30});const intervalWeight=Object(d3_array__WEBPACK_IMPORTED_MODULE_1__[\"sum\"])(nodeWeights.values());results.push({interval,intervalWeight,distribution:distributionResult.pi});// Use the latest convergce results as the starting point for the next run\n// of PageRank\npi0=distributionResult.pi;}return results;}\n\n//# sourceURL=webpack:///./src/analysis/timeline/timelinePagerank.js?");

/***/ }),

/***/ "./src/analysis/weightEvaluator.js":
/*!*****************************************!*\
  !*** ./src/analysis/weightEvaluator.js ***!
  \*****************************************/
/*! exports provided: nodeWeightEvaluator, edgeWeightEvaluator */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"nodeWeightEvaluator\", function() { return nodeWeightEvaluator; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"edgeWeightEvaluator\", function() { return edgeWeightEvaluator; });\n/* harmony import */ var _util_null__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/null */ \"./src/util/null.js\");\n/* harmony import */ var _core_trie__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/trie */ \"./src/core/trie.js\");\n/**\n * Given the weights and types, produces a NodeEvaluator, which assigns a weight to a\n * NodeAddressT based on its type and whether it has any manual weight specified.\n *\n * Every node address is assigned a weight based on its most specific matching\n * type (i.e. the type with the longest shared prefix). If that type has a\n * weight specified in the typeWeights map, the specified weight will be used.\n * If not, then the type's default weight is used. If no type matches a given\n * node, then it will get a default weight of 1.\n *\n * If the node address has a manual weight specified in the manualWeights map,\n * that weight will be multiplied by its type weight.\n */function nodeWeightEvaluator(types,weights){const{nodeTypeWeights:typeWeights,nodeManualWeights:manualWeights}=weights;const nodeTrie=new _core_trie__WEBPACK_IMPORTED_MODULE_1__[\"NodeTrie\"]();for(const{prefix,defaultWeight}of types){const weight=_util_null__WEBPACK_IMPORTED_MODULE_0__[\"orElse\"](typeWeights.get(prefix),defaultWeight);nodeTrie.add(prefix,weight);}return function nodeWeight(a){const typeWeight=_util_null__WEBPACK_IMPORTED_MODULE_0__[\"orElse\"](nodeTrie.getLast(a),1);const manualWeight=_util_null__WEBPACK_IMPORTED_MODULE_0__[\"orElse\"](manualWeights.get(a),1);return typeWeight*manualWeight;};}/**\n * Given the weights and types, produce an EdgeEvaluator, which assigns a toWeight and froWeight\n * to an edge address based only on its type.\n */function edgeWeightEvaluator(types,weights){const typeWeights=weights.edgeTypeWeights;const edgeTrie=new _core_trie__WEBPACK_IMPORTED_MODULE_1__[\"EdgeTrie\"]();for(const{prefix,defaultWeight}of types){const weight=_util_null__WEBPACK_IMPORTED_MODULE_0__[\"orElse\"](typeWeights.get(prefix),defaultWeight);edgeTrie.add(prefix,weight);}return function evaluator(address){return _util_null__WEBPACK_IMPORTED_MODULE_0__[\"orElse\"](edgeTrie.getLast(address),{forwards:1,backwards:1});};}\n\n//# sourceURL=webpack:///./src/analysis/weightEvaluator.js?");

/***/ }),

/***/ "./src/analysis/weights.js":
/*!*********************************!*\
  !*** ./src/analysis/weights.js ***!
  \*********************************/
/*! exports provided: defaultWeights, copy, toJSON, fromJSON */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"defaultWeights\", function() { return defaultWeights; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"copy\", function() { return copy; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"toJSON\", function() { return toJSON; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fromJSON\", function() { return fromJSON; });\n/* harmony import */ var _util_map__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/map */ \"./src/util/map.js\");\n/* harmony import */ var _util_compat__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/compat */ \"./src/util/compat.js\");\n/**\n * Represents the weight for a particular Node (or NodeType).\n * Weight 1 is the default value and signifies normal importance.\n * Weights are linear, so 2 is twice as important as 1.\n */ /**\n * Creates default (i.e. empty) weights.\n *\n * When the weights are empty, defaults will be used for every type and node.\n */function defaultWeights(){return{nodeTypeWeights:new Map(),edgeTypeWeights:new Map(),nodeManualWeights:new Map()};}function copy(w){return{nodeTypeWeights:new Map(w.nodeTypeWeights),edgeTypeWeights:new Map(w.edgeTypeWeights),nodeManualWeights:new Map(w.nodeManualWeights)};}const COMPAT_INFO={type:\"sourcecred/weights\",version:\"0.1.0\"};function toJSON(weights){return Object(_util_compat__WEBPACK_IMPORTED_MODULE_1__[\"toCompat\"])(COMPAT_INFO,{nodeTypeWeights:_util_map__WEBPACK_IMPORTED_MODULE_0__[\"toObject\"](weights.nodeTypeWeights),edgeTypeWeights:_util_map__WEBPACK_IMPORTED_MODULE_0__[\"toObject\"](weights.edgeTypeWeights),nodeManualWeights:_util_map__WEBPACK_IMPORTED_MODULE_0__[\"toObject\"](weights.nodeManualWeights)});}function fromJSON(json){const{nodeTypeWeights,edgeTypeWeights,nodeManualWeights}=Object(_util_compat__WEBPACK_IMPORTED_MODULE_1__[\"fromCompat\"])(COMPAT_INFO,json);return{nodeTypeWeights:_util_map__WEBPACK_IMPORTED_MODULE_0__[\"fromObject\"](nodeTypeWeights),edgeTypeWeights:_util_map__WEBPACK_IMPORTED_MODULE_0__[\"fromObject\"](edgeTypeWeights),nodeManualWeights:_util_map__WEBPACK_IMPORTED_MODULE_0__[\"fromObject\"](nodeManualWeights)};}\n\n//# sourceURL=webpack:///./src/analysis/weights.js?");

/***/ }),

/***/ "./src/api/index.js":
/*!**************************!*\
  !*** ./src/api/index.js ***!
  \**************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var deep_freeze__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! deep-freeze */ \"deep-freeze\");\n/* harmony import */ var deep_freeze__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(deep_freeze__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _core_address__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/address */ \"./src/core/address.js\");\n/* harmony import */ var _plugins_discourse_address__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../plugins/discourse/address */ \"./src/plugins/discourse/address.js\");\n/* harmony import */ var _plugins_discourse_declaration__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../plugins/discourse/declaration */ \"./src/plugins/discourse/declaration.js\");\n/* harmony import */ var _plugins_github_declaration__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../plugins/github/declaration */ \"./src/plugins/github/declaration.js\");\n/* harmony import */ var _plugins_github_edges__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../plugins/github/edges */ \"./src/plugins/github/edges.js\");\n/* harmony import */ var _plugins_github_nodes__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../plugins/github/nodes */ \"./src/plugins/github/nodes.js\");\n/* harmony import */ var _core_graph__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../core/graph */ \"./src/core/graph.js\");\n/* harmony import */ var _core_attribution_graphToMarkovChain__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../core/attribution/graphToMarkovChain */ \"./src/core/attribution/graphToMarkovChain.js\");\n/* harmony import */ var _core_attribution_markovChain__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../core/attribution/markovChain */ \"./src/core/attribution/markovChain.js\");\n/* harmony import */ var _analysis_timeline_timelineCred__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../analysis/timeline/timelineCred */ \"./src/analysis/timeline/timelineCred.js\");\n// Exports for calling SourceCred code programmatically. Both the\n// structure and the contents of this API are experimental and subject\n// to change.\n/* harmony default export */ __webpack_exports__[\"default\"] = (deep_freeze__WEBPACK_IMPORTED_MODULE_0___default()({analysis:{timeline:{timelineCred: _analysis_timeline_timelineCred__WEBPACK_IMPORTED_MODULE_10__}},core:{address: _core_address__WEBPACK_IMPORTED_MODULE_1__,attribution:{markovChain: _core_attribution_markovChain__WEBPACK_IMPORTED_MODULE_9__,graphToMarkovChain: _core_attribution_graphToMarkovChain__WEBPACK_IMPORTED_MODULE_8__},graph: _core_graph__WEBPACK_IMPORTED_MODULE_7__},plugins:{github:{declaration:_plugins_github_declaration__WEBPACK_IMPORTED_MODULE_4__,edges:_plugins_github_edges__WEBPACK_IMPORTED_MODULE_5__,nodes:_plugins_github_nodes__WEBPACK_IMPORTED_MODULE_6__},discourse:{address:_plugins_discourse_address__WEBPACK_IMPORTED_MODULE_2__,declaration:_plugins_discourse_declaration__WEBPACK_IMPORTED_MODULE_3__}}}));\n\n//# sourceURL=webpack:///./src/api/index.js?");

/***/ }),

/***/ "./src/core/address.js":
/*!*****************************!*\
  !*** ./src/core/address.js ***!
  \*****************************/
/*! exports provided: makeAddressModule */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"makeAddressModule\", function() { return makeAddressModule; });\n/* harmony import */ var json_stable_stringify__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! json-stable-stringify */ \"json-stable-stringify\");\n/* harmony import */ var json_stable_stringify__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(json_stable_stringify__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var deep_freeze__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! deep-freeze */ \"deep-freeze\");\n/* harmony import */ var deep_freeze__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(deep_freeze__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _util_map__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/map */ \"./src/util/map.js\");\nfunction makeAddressModule(options){// for readability and interface consistency\nconst{name,nonce}=options;const otherNonces=new Map(options.otherNonces||new Map());const separator=\"\\0\";if(nonce.indexOf(separator)!==-1){throw new Error(\"invalid nonce (contains NUL): \".concat(json_stable_stringify__WEBPACK_IMPORTED_MODULE_0___default()(nonce)));}const nonceWithSeparator=nonce+separator;const otherNoncesWithSeparators=_util_map__WEBPACK_IMPORTED_MODULE_2__[\"mapKeys\"](otherNonces,otherNonce=>{if(otherNonce===nonce){throw new Error(\"primary nonce listed as otherNonce: \".concat(json_stable_stringify__WEBPACK_IMPORTED_MODULE_0___default()(nonce)));}if(otherNonce.indexOf(separator)!==-1){throw new Error(\"invalid otherNonce (contains NUL): \".concat(json_stable_stringify__WEBPACK_IMPORTED_MODULE_0___default()(otherNonce)));}return otherNonce+separator;});function assertValid(address,what){// istanbul ignore if\nif(true){// Catching invalid addresses in test code should be sufficient\nreturn;}const prefix=what==null?\"\":\"\".concat(what,\": \");if(address==null){throw new Error(prefix+\"expected \".concat(name,\", got: \").concat(String(address)));}if(!address.endsWith(separator)){throw new Error(prefix+\"expected \".concat(name,\", got: \").concat(json_stable_stringify__WEBPACK_IMPORTED_MODULE_0___default()(address)));}if(!address.startsWith(nonceWithSeparator)){for(const[otherNonceWithSeparator,otherName]of otherNoncesWithSeparators){if(address.startsWith(otherNonceWithSeparator)){throw new Error(prefix+\"expected \".concat(name,\", got \").concat(otherName,\": \").concat(json_stable_stringify__WEBPACK_IMPORTED_MODULE_0___default()(address)));}}throw new Error(prefix+\"expected \".concat(name,\", got: \").concat(json_stable_stringify__WEBPACK_IMPORTED_MODULE_0___default()(address)));}}function partsString(parts){// This is needed to properly print arrays containing `undefined`.\nreturn\"[\"+parts.map(p=>String(json_stable_stringify__WEBPACK_IMPORTED_MODULE_0___default()(p))).join(\",\")+\"]\";}function assertValidParts(parts,what){// istanbul ignore if\nif(true){// Catching invalid parts in test code should be sufficient\nreturn;}const prefix=what==null?\"\":\"\".concat(what,\": \");if(parts==null){throw new Error(prefix+\"expected array of parts, got: \".concat(String(parts)));}parts.forEach(s=>{if(s==null){throw new Error(prefix+\"expected array of parts, got \".concat(String(s),\" in: \").concat(partsString(parts)));}if(s.indexOf(separator)!==-1){const where=\"\".concat(json_stable_stringify__WEBPACK_IMPORTED_MODULE_0___default()(s),\" in \").concat(partsString(parts));throw new Error(prefix+\"part contains NUL character: \".concat(where));}});}function nullDelimited(components){return[...components,\"\"].join(separator);}function fromParts(parts){assertValidParts(parts);return nonce+separator+nullDelimited(parts);}const empty=fromParts([]);function toParts(address){assertValid(address);const parts=address.split(separator);return parts.slice(1,parts.length-1);}function toString(address){const parts=toParts(address);return\"\".concat(name).concat(json_stable_stringify__WEBPACK_IMPORTED_MODULE_0___default()(parts));}function append(address){assertValid(address);for(var _len=arguments.length,parts=new Array(_len>1?_len-1:0),_key=1;_key<_len;_key++){parts[_key-1]=arguments[_key];}assertValidParts(parts);return address+nullDelimited(parts);}function hasPrefix(address,prefix){assertValid(address,\"address\");assertValid(prefix,\"prefix\");return address.startsWith(prefix);}const result={assertValid,assertValidParts,empty,fromParts,toParts,toString,append,hasPrefix};return deep_freeze__WEBPACK_IMPORTED_MODULE_1___default()(result);}\n\n//# sourceURL=webpack:///./src/core/address.js?");

/***/ }),

/***/ "./src/core/attribution/distribution.js":
/*!**********************************************!*\
  !*** ./src/core/attribution/distribution.js ***!
  \**********************************************/
/*! exports provided: uniformDistribution, computeDelta */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"uniformDistribution\", function() { return uniformDistribution; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"computeDelta\", function() { return computeDelta; });\n/**\n * A distribution over the integers `0` through `n - 1`, where `n` is\n * the length of the array. The value at index `i` is the probability of\n * `i` in the distribution. The values should sum to 1.\n */function uniformDistribution(n){if(isNaN(n)||!isFinite(n)||n!==Math.floor(n)||n<=0){throw new Error(\"expected positive integer, but got: \"+n);}return new Float64Array(n).fill(1/n);}/**\n * Compute the maximum difference (in absolute value) between components in two\n * distributions.\n *\n * Equivalent to $\\norm{pi0 - pi1}_\\infty$.\n */function computeDelta(pi0,pi1){if(pi0.length===0||pi0.length!==pi1.length){throw new Error(\"invalid input\");}let maxDelta=-Infinity;// Here, we assume that `pi0.nodeOrder` and `pi1.nodeOrder` are the\n// same (i.e., there has been no permutation).\npi0.forEach((x,i)=>{const delta=Math.abs(x-pi1[i]);maxDelta=Math.max(delta,maxDelta);});return maxDelta;}\n\n//# sourceURL=webpack:///./src/core/attribution/distribution.js?");

/***/ }),

/***/ "./src/core/attribution/graphToMarkovChain.js":
/*!****************************************************!*\
  !*** ./src/core/attribution/graphToMarkovChain.js ***!
  \****************************************************/
/*! exports provided: adjacencySource, createConnections, createOrderedSparseMarkovChain, permute, normalizeNeighbors, normalize, distributionToNodeDistribution */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"adjacencySource\", function() { return adjacencySource; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"createConnections\", function() { return createConnections; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"createOrderedSparseMarkovChain\", function() { return createOrderedSparseMarkovChain; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"permute\", function() { return permute; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"normalizeNeighbors\", function() { return normalizeNeighbors; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"normalize\", function() { return normalize; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"distributionToNodeDistribution\", function() { return distributionToNodeDistribution; });\n/* harmony import */ var _util_map__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util/map */ \"./src/util/map.js\");\n/* harmony import */ var _util_null__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/null */ \"./src/util/null.js\");\nfunction adjacencySource(target,adjacency){switch(adjacency.type){case\"SYNTHETIC_LOOP\":return target;case\"IN_EDGE\":return adjacency.edge.src;case\"OUT_EDGE\":return adjacency.edge.dst;default:throw new Error(adjacency.type);}}function createConnections(graph,edgeWeight,syntheticLoopWeight){const result=new Map();const totalOutWeight=new Map();for(const node of graph.nodes()){result.set(node.address,[]);totalOutWeight.set(node.address,0);}function processConnection(target,connection){const connections=_util_null__WEBPACK_IMPORTED_MODULE_1__[\"get\"](result.get(target));connections.push(connection);const source=adjacencySource(target,connection.adjacency);const priorOutWeight=_util_null__WEBPACK_IMPORTED_MODULE_1__[\"get\"](totalOutWeight.get(source));totalOutWeight.set(source,priorOutWeight+connection.weight);}// Add self-loops.\nfor(const node of graph.nodes()){processConnection(node.address,{adjacency:{type:\"SYNTHETIC_LOOP\"},weight:syntheticLoopWeight});}// Process edges.\nfor(const edge of graph.edges({showDangling:false})){const{forwards,backwards}=edgeWeight(edge);const{src,dst}=edge;processConnection(dst,{adjacency:{type:\"IN_EDGE\",edge},weight:forwards});processConnection(src,{adjacency:{type:\"OUT_EDGE\",edge},weight:backwards});}// Normalize in-weights.\nfor(const[target,connections]of result.entries()){for(const connection of connections){const source=adjacencySource(target,connection.adjacency);const normalization=_util_null__WEBPACK_IMPORTED_MODULE_1__[\"get\"](totalOutWeight.get(source));const newWeight=connection.weight/normalization;// (any-cast because property is not writable)\nconnection.weight=newWeight;}}return result;}function createNodeAddressMarkovChain(ntc){return _util_map__WEBPACK_IMPORTED_MODULE_0__[\"mapValues\"](ntc,(target,connections)=>{const inNeighbors=new Map();for(const connection of connections){const source=adjacencySource(target,connection.adjacency);inNeighbors.set(source,connection.weight+_util_null__WEBPACK_IMPORTED_MODULE_1__[\"orElse\"](inNeighbors.get(source),0));}return inNeighbors;});}function nodeAddressMarkovChainToOrderedSparseMarkovChain(chain){const nodeOrder=Array.from(chain.keys());const addressToIndex=new Map();nodeOrder.forEach((node,index)=>{addressToIndex.set(node,index);});return{nodeOrder,chain:nodeOrder.map(dst=>{const theseNeighbors=_util_null__WEBPACK_IMPORTED_MODULE_1__[\"get\"](chain.get(dst));const result={neighbor:new Uint32Array(theseNeighbors.size),weight:new Float64Array(theseNeighbors.size)};let i=0;for(const[src,weight]of theseNeighbors.entries()){const srcIndex=_util_null__WEBPACK_IMPORTED_MODULE_1__[\"get\"](addressToIndex.get(src));result.neighbor[i]=srcIndex;result.weight[i]=weight;i++;}return result;})};}function createOrderedSparseMarkovChain(connections){const chain=createNodeAddressMarkovChain(connections);return nodeAddressMarkovChainToOrderedSparseMarkovChain(chain);}/**\n * Return an equivalent form of the given chain whose `nodeOrder` is the\n * provided array, which must be a permutation of the node order of the\n * original chain.\n */function permute(old,newOrder){const newIndices={};const oldIndices={};newOrder.forEach((node,i)=>{newIndices[node]=i;});old.nodeOrder.forEach((node,i)=>{oldIndices[node]=i;});const newChain=[];for(const node of newOrder){const{neighbor:oldNeighbors,weight}=old.chain[oldIndices[node]];const newNeighbors=oldNeighbors.map(oldIndex=>newIndices[old.nodeOrder[oldIndex]]);newChain.push({neighbor:newNeighbors,weight});}return{nodeOrder:newOrder,chain:newChain};}/**\n * Return an equivalent form of the given chain such that for for each\n * node, the entries in `chain[node].neighbors` are sorted.\n */function normalizeNeighbors(old){return{nodeOrder:old.nodeOrder,chain:old.chain.map((_ref)=>{let{neighbor,weight}=_ref;if(neighbor.length!==weight.length){throw new Error(\"\".concat(neighbor.length,\" !== \").concat(weight.length));}const entries=Array(neighbor.length).fill(null).map((_,i)=>({neighbor:neighbor[i],weight:weight[i]}));entries.sort((a,b)=>a.neighbor-b.neighbor);return{neighbor:new Uint32Array(entries.map(x=>x.neighbor)),weight:new Float64Array(entries.map(x=>x.weight))};})};}function normalize(old){return normalizeNeighbors(permute(old,old.nodeOrder.slice().sort()));}function distributionToNodeDistribution(nodeOrder,pi){const result=new Map();nodeOrder.forEach((node,i)=>{const probability=pi[i];result.set(node,probability);});return result;}\n\n//# sourceURL=webpack:///./src/core/attribution/graphToMarkovChain.js?");

/***/ }),

/***/ "./src/core/attribution/markovChain.js":
/*!*********************************************!*\
  !*** ./src/core/attribution/markovChain.js ***!
  \*********************************************/
/*! exports provided: sparseMarkovChainFromTransitionMatrix, sparseMarkovChainAction, findStationaryDistribution */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"sparseMarkovChainFromTransitionMatrix\", function() { return sparseMarkovChainFromTransitionMatrix; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"sparseMarkovChainAction\", function() { return sparseMarkovChainAction; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"findStationaryDistribution\", function() { return findStationaryDistribution; });\n/* harmony import */ var _distribution__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./distribution */ \"./src/core/attribution/distribution.js\");\n/**\n * The data inputs to running PageRank.\n *\n * We keep these separate from the PagerankOptions below,\n * because we expect that within a given context, every call to\n * findStationaryDistribution (or other Pagerank functions) will\n * have different PagerankParams, but often have the same PagerankOptions.\n */function sparseMarkovChainFromTransitionMatrix(matrix){const n=matrix.length;matrix.forEach((row,i)=>{if(row.length!==n){throw new Error(\"expected rows to have length \".concat(n,\", but row \").concat(i,\" has \").concat(row.length));}});matrix.forEach((row,i)=>{row.forEach((value,j)=>{if(isNaN(value)||!isFinite(value)||value<0){throw new Error(\"expected positive real entries, but [\".concat(i,\"][\").concat(j,\"] is \").concat(value));}});});matrix.forEach((row,i)=>{const rowsum=row.reduce((a,b)=>a+b,0);if(Math.abs(rowsum-1)>1e-6){throw new Error(\"expected rows to sum to 1, but row \".concat(i,\" sums to \").concat(rowsum));}});return matrix.map((_,j)=>{const column=matrix.map((row,i)=>[i,row[j]]).filter((_ref)=>{let[_,p]=_ref;return p>0;});return{neighbor:new Uint32Array(column.map((_ref2)=>{let[i,_]=_ref2;return i;})),weight:new Float64Array(column.map((_ref3)=>{let[_,p]=_ref3;return p;}))};});}function sparseMarkovChainActionInto(chain,seed,alpha,input,output){chain.forEach((_ref4,dst)=>{let{neighbor,weight}=_ref4;const inDegree=neighbor.length;// (also `weight.length`)\nlet probability=alpha*seed[dst];for(let i=0;i<inDegree;i++){const src=neighbor[i];probability+=(1-alpha)*input[src]*weight[i];}output[dst]=probability;});}function sparseMarkovChainAction(chain,seed,alpha,pi){const result=new Float64Array(pi.length);sparseMarkovChainActionInto(chain,seed,alpha,pi,result);return result;}function*findStationaryDistributionGenerator(params,options){const{chain,pi0,seed,alpha}=params;let pi=new Float64Array(pi0);let scratch=new Float64Array(pi.length);let nIterations=0;while(true){if(nIterations>=options.maxIterations){if(options.verbose){console.log(\"[\".concat(nIterations,\"] FAILED to converge\"));}// We need to do one more step so that we can compute the empirical convergence\n// delta for the returned distribution.\nsparseMarkovChainActionInto(chain,seed,alpha,pi,scratch);const convergenceDelta=Object(_distribution__WEBPACK_IMPORTED_MODULE_0__[\"computeDelta\"])(pi,scratch);return{pi,convergenceDelta};}nIterations++;sparseMarkovChainActionInto(chain,seed,alpha,pi,scratch);// We compute the convergenceDelta between 'scratch' (the newest\n// distribution) and 'pi' (the distribution from the previous step). If the\n// delta is below threshold, then the distribution from the last step was\n// already converged and we return it (not scratch). Otherwise, we assign\n// `scratch` to `distribution` and try again.\nconst convergenceDelta=Object(_distribution__WEBPACK_IMPORTED_MODULE_0__[\"computeDelta\"])(pi,scratch);if(options.verbose){console.log(\"[\".concat(nIterations,\"] delta = \").concat(convergenceDelta));}if(convergenceDelta<options.convergenceThreshold){if(options.verbose){console.log(\"[\".concat(nIterations,\"] CONVERGED\"));}return{pi,convergenceDelta};}[scratch,pi]=[pi,scratch];yield;}// ESLint knows that this next line is unreachable, but Flow doesn't. :-)\n// eslint-disable-next-line no-unreachable\nthrow new Error(\"Unreachable.\");}function findStationaryDistribution(params,options){let gen=findStationaryDistributionGenerator(params,{verbose:options.verbose,convergenceThreshold:options.convergenceThreshold,maxIterations:options.maxIterations});return new Promise((resolve,_unused_reject)=>{const{yieldAfterMs}=options;const tick=()=>{const start=Date.now();do{const result=gen.next();if(result.done){if(result.value==null){// Should never happen.\nthrow new Error(String(result.value));}resolve(result.value);return;}}while(Date.now()-start<yieldAfterMs);setTimeout(tick,0);};tick();});}\n\n//# sourceURL=webpack:///./src/core/attribution/markovChain.js?");

/***/ }),

/***/ "./src/core/attribution/nodeDistribution.js":
/*!**************************************************!*\
  !*** ./src/core/attribution/nodeDistribution.js ***!
  \**************************************************/
/*! exports provided: distributionToNodeDistribution, weightedDistribution */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"distributionToNodeDistribution\", function() { return distributionToNodeDistribution; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"weightedDistribution\", function() { return weightedDistribution; });\n/* harmony import */ var _graph__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../graph */ \"./src/core/graph.js\");\n/* harmony import */ var _distribution__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./distribution */ \"./src/core/attribution/distribution.js\");\nfunction distributionToNodeDistribution(nodeOrder,pi){const result=new Map();nodeOrder.forEach((node,i)=>{const probability=pi[i];result.set(node,probability);});return result;}/**\n * Create a Distribution using provided node weights.\n *\n * weightedDistribution takes in a node order (as a read only array of NodeAddressT),\n * and a map providing weights for a subset of those nodes. It returns a Distribution\n * with the invariant that every node's weight is proportional to its relative weight\n * in the weights map. For example, in a case where there were three nodes and they\n * had weights of 0, 1, and 3 respectively, the distribution would be [0, 0.25, 0.75].\n *\n * If a node address is not present in the weight map, its weight is assumed to be 0.\n * If any weight is negative or non-finite, an error will be thrown.\n * If the sum of all weights is 0, then a uniform distribution will be returned.\n * If the weight map assigned weight to nodes which are not in the node order, an error\n * will be thrown.\n */function weightedDistribution(nodeOrder,weights){let totalWeight=0;for(const[address,weight]of weights.entries()){if(weight<0||!isFinite(weight)){throw new Error(\"Invalid weight \".concat(weight,\" associated with address \").concat(_graph__WEBPACK_IMPORTED_MODULE_0__[\"NodeAddress\"].toString(address)));}totalWeight+=weight;}if(totalWeight===0){return Object(_distribution__WEBPACK_IMPORTED_MODULE_1__[\"uniformDistribution\"])(nodeOrder.length);}let numEncounteredWeights=0;const distribution=new Float64Array(nodeOrder.length);for(let i=0;i<distribution.length;i++){const weight=weights.get(nodeOrder[i]);if(weight!=null){numEncounteredWeights++;distribution[i]=weight/totalWeight;}}if(numEncounteredWeights!==weights.size){throw new Error(\"weights included nodes not present in the nodeOrder\");}return distribution;}\n\n//# sourceURL=webpack:///./src/core/attribution/nodeDistribution.js?");

/***/ }),

/***/ "./src/core/graph.js":
/*!***************************!*\
  !*** ./src/core/graph.js ***!
  \***************************/
/*! exports provided: NodeAddress, EdgeAddress, Direction, Graph, nodeToString, edgeToString, edgeToStrings, edgeToParts */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"NodeAddress\", function() { return NodeAddress; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"EdgeAddress\", function() { return EdgeAddress; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Direction\", function() { return Direction; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Graph\", function() { return Graph; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"nodeToString\", function() { return nodeToString; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"edgeToString\", function() { return edgeToString; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"edgeToStrings\", function() { return edgeToStrings; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"edgeToParts\", function() { return edgeToParts; });\n/* harmony import */ var lodash_isequal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash.isequal */ \"lodash.isequal\");\n/* harmony import */ var lodash_isequal__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash_isequal__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var deep_freeze__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! deep-freeze */ \"deep-freeze\");\n/* harmony import */ var deep_freeze__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(deep_freeze__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _address__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./address */ \"./src/core/address.js\");\n/* harmony import */ var _util_compat__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../util/compat */ \"./src/util/compat.js\");\n/* harmony import */ var _util_null__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../util/null */ \"./src/util/null.js\");\nfunction ownKeys(object,enumerableOnly){var keys=Object.keys(object);if(Object.getOwnPropertySymbols){var symbols=Object.getOwnPropertySymbols(object);if(enumerableOnly)symbols=symbols.filter(function(sym){return Object.getOwnPropertyDescriptor(object,sym).enumerable;});keys.push.apply(keys,symbols);}return keys;}function _objectSpread(target){for(var i=1;i<arguments.length;i++){var source=arguments[i]!=null?arguments[i]:{};if(i%2){ownKeys(Object(source),true).forEach(function(key){_defineProperty(target,key,source[key]);});}else if(Object.getOwnPropertyDescriptors){Object.defineProperties(target,Object.getOwnPropertyDescriptors(source));}else{ownKeys(Object(source)).forEach(function(key){Object.defineProperty(target,key,Object.getOwnPropertyDescriptor(source,key));});}}return target;}function _defineProperty(obj,key,value){if(key in obj){Object.defineProperty(obj,key,{value:value,enumerable:true,configurable:true,writable:true});}else{obj[key]=value;}return obj;}/**\n * This module contains the Graph, which is one of the most fundamental pieces\n * of SourceCred. SourceCred uses this graph to model all of the contributions\n * that make up a project, and the relationships between those contributions.\n *\n * If you aren't familiar with computer science graphs, now would be a good\n * time to refresh. See [this StackOverflow answer][1] for an introduction, and\n * [Wikipedia][2] for a more thorough overview. This Graph is used by\n * SourceCred as a \"Contribution Graph\", where every node is a contribution or\n * contributor (e.g. a pull request, or a GitHub user identity) and every edge\n * represents a connection between contributions or contributors (e.g. a pull\n * request contains a comment, or a comment is authored by a user).\n *\n * [1]: https://softwareengineering.stackexchange.com/questions/168058/what-are-graphs-in-laymens-terms#168067\n * [2]: https://en.wikipedia.org/wiki/Graph_(abstract_data_type)\n *\n * The Graph serves a simple function: it keeps track of which Nodes exist, and\n * what Edges join those nodes to each other. Nodes and Edges are both identified\n * by Addresses; specifically, `NodeAddressT`s and `EdgeAddressT`s.\n *\n * In both cases, addresses are modeled as arrays of strings. For example,\n * you might want to give an address to your favorite node. You can do so as\n * follows:\n *\n * const myAddress: NodeAddressT = NodeAddress.fromParts([\"my\", \"favorite\"])\n *\n * Edge Addresses are quite similar, except you use the EdgeAddress module.\n *\n * We model addresses as arrays of strings so that plugins can apply\n * hierarchical namespacing for the address. In general, for any address, the\n * first piece should be the name of the organization that owns the plugin, and\n * the second piece should be the name of the plugin. Pieces thereafter are\n * namespaced by the plugin's internal logic. For example, SourceCred has a\n * Git plugin, and that plugin produces addresses like\n * [\"sourcecred\", \"git\", \"commit\", \"9cba0e9e212a287ce26e8d7c2d273e1025c9f9bf\"].\n *\n * This enables \"prefix matching\" for finding only certain types of nodes. For\n * example, if we wanted to find every Git commit in the graph, we\n * could use the following code:\n *\n * const commitPrefix = NodeAddress.fromParts([\"sourcecred\", \"git\", \"commit\"]);\n * const commitNodes = graph.nodes({prefix: commitPrefix});\n *\n * The graph represents nodes as the `Node` data type, which includes an\n * address (NodeAddressT) as well as a few other fields that are needed for\n * calculating and displaying cred. The Graph is intended to be a lightweight\n * data structure, so only data directly needed for cred analysis is included.\n * If there's other data you want to store (e.g. the full text of posts that\n * are tracked in the graph), you can use the node address as a key for a\n * separate database.\n *\n * Edges are represented by `Edge` objects. They have `src` and `dst` fields.\n * These fields represent the \"source\" of the edge and the \"destination\" of the\n * edge respectively, and both fields contain `NodeAddressT`s. The edge also\n * has its own address, which is an `EdgeAddressT`.\n *\n * Graphs are allowed to contain Edges whose `src` or `dst` are not present.\n * Such edges are called 'Dangling Edges'. An edge may convert from dangling to\n * non-dangling (if it is added before its src or dst), and it may convert from\n * non-dangling to dangling (if its src or dst are removed).\n *\n * Supporting dangling edges is important, because it means that we can require\n * metadata be present for a Node (e.g. its creation timestamp), and still\n * allow graph creators that do not know a node's metadata to create references\n * to it. (Of course, they still need to know the node's address).\n *\n * Here's a toy example of creating a graph:\n *\n * ```js\n * const prAddress = NodeAddress.fromParts([\"pull_request\", \"1\"]);\n * const prDescription = \"My Fancy Pull Request\"\n * const pr: Node = {address: prAddress, description: prDescription, timestampMs: +Date.now()}\n * const myAddress = NodeAddress.fromParts([\"user\", \"decentralion\"]);\n * const myDescription = \"@decentralion\"\n * const me: Node = {addess: myAddress, description: myDescription, timestampMs: null}\n * const authoredAddress = EdgeAddress.fromParts([\"authored\", \"pull_request\", \"1\"]);\n * const edge = {src: me, dst: pr, address: authoredAddress, timestampMs: +Date.now()};\n *\n * const g = new Graph();\n * g.addNode(pr);\n * g.addNode(me);\n * g.addEdge(edge);\n * ```\n *\n * Graph has a number of accessor methods:\n * - `hasNode` to check if a node address is in the Graph\n * - `node` to retrieve a node by its address\n * - `nodes` to iterate over the nodes in the graph\n * - `hasEdge` to check if an edge address is in the Graph\n * - `isDanglingEdge` to check if an edge is dangling\n * - `edge` to retrieve an edge by its address\n * - `edges` to iterate over the edges in the graph\n * - `neighbors` to find all the edges and nodes adjacent to a node\n *    (also supports filtering by direction, by node prefix, or edge prefix)\n *\n * The Graph also has a few other convenience methods, like toJSON/fromJSON\n * for serialization, and `Graph.merge` for combining multiple graphs.\n */const NodeAddress=Object(_address__WEBPACK_IMPORTED_MODULE_2__[\"makeAddressModule\"])({name:\"NodeAddress\",nonce:\"N\",otherNonces:new Map().set(\"E\",\"EdgeAddress\")});const EdgeAddress=Object(_address__WEBPACK_IMPORTED_MODULE_2__[\"makeAddressModule\"])({name:\"EdgeAddress\",nonce:\"E\",otherNonces:new Map().set(\"N\",\"NodeAddress\")});/**\n * Represents a node in the graph.\n */const COMPAT_INFO={type:\"sourcecred/graph\",version:\"0.8.0\"};const Direction=deep_freeze__WEBPACK_IMPORTED_MODULE_1___default()({IN:Symbol(\"IN\"),OUT:Symbol(\"OUT\"),ANY:Symbol(\"ANY\")});class Graph{// Map every node address present in the graph to its inEdges (edges for\n// which it is a dst) and outEdges (edges for which it is a src)\n// Incremented each time that any change is made to the graph. Used to\n// check for comodification and to avoid needlessly checking\n// invariants.\nconstructor(){_defineProperty(this,\"_nodes\",void 0);_defineProperty(this,\"_edges\",void 0);_defineProperty(this,\"_incidentEdges\",void 0);_defineProperty(this,\"_modificationCount\",void 0);_defineProperty(this,\"_cachedOrder\",void 0);_defineProperty(this,\"_invariantsLastChecked\",void 0);this._modificationCount=0;this._invariantsLastChecked={when:-1,failure:\"Invariants never checked\"};this._cachedOrder={nodeOrder:[],edgeOrder:[],modificationCount:0};this._nodes=new Map();this._edges=new Map();this._incidentEdges=new Map();this._maybeCheckInvariants();}_checkForComodification(since){// TODO(perf): Consider eliding this in production.\nconst now=this._modificationCount;if(now===since){this._maybeCheckInvariants();return;}if(now>since){throw new Error(\"Concurrent modification detected\");}if(now<since){throw new Error(\"Invariant violation: expected modification count in the future\");}this._maybeCheckInvariants();}_markModification(){// TODO(perf): Consider eliding this in production.\nif(this._modificationCount>=Number.MAX_SAFE_INTEGER){throw new Error(\"Graph cannot be modified more than \".concat(this._modificationCount,\" times.\"));}this._modificationCount++;this._maybeCheckInvariants();}/**\n   * A node address is 'referenced' if it is either present in the graph, or is\n   * the src or dst of some edge.\n   *\n   * Referenced nodes always have an entry in this._incidentEdges (regardless\n   * of whether they are incident to any edges).\n   *\n   * This method ensures that a given node address has a reference.\n   */_reference(n){if(!this._incidentEdges.has(n)){this._incidentEdges.set(n,{inEdges:[],outEdges:[]});}}/**\n   * A node stops being referenced as soon as it is both not in the graph, and is\n   * not incident to any edge. This method must be called after any operation which\n   * might cause a node address to no longer be referenced, so that the node can\n   * be unreferenced if appropriate.\n   */_unreference(n){const incidence=this._incidentEdges.get(n);if(incidence!=null){const{inEdges,outEdges}=incidence;if(!this._nodes.has(n)&&inEdges.length===0&&outEdges.length===0){this._incidentEdges.delete(n);}}}_getOrder(){const modificationCount=this._modificationCount;if(this._cachedOrder.modificationCount!==modificationCount){const edgeOrder=Array.from(this._edges.keys()).sort();const nodeOrder=Array.from(this._nodes.keys()).sort();this._cachedOrder={nodeOrder,edgeOrder,modificationCount};}return this._cachedOrder;}/**\n   * Returns how many times the graph has been modified.\n   *\n   * This value is exposed so that users of Graph can cache computations over\n   * the graph with confidence, knowing that they will be able to check the\n   * modification count to know when their cache is potentially invalid.\n   *\n   * This value may increase any time the graph is potentially modified, even\n   * if no modification actually occurs; for example, if a client calls\n   * `addNode`, the modification count may increase even if the added node was\n   * already present in the graph.\n   *\n   * This value is not serialized, and is ignored when checking equality, i.e.\n   * two graphs may be semantically equal even when they have different\n   * modification counts.\n   */modificationCount(){return this._modificationCount;}/**\n   * Adds a new node to the graph.\n   *\n   * If the node already exists in the graph, no action is taken and no error\n   * is thrown. (This operation is idempotent).\n   *\n   * Returns `this` for chaining.\n   */addNode(node){const{address}=node;NodeAddress.assertValid(address);this._reference(address);const existingNode=this._nodes.get(address);if(existingNode==null){this._nodes.set(address,node);}else{if(!lodash_isequal__WEBPACK_IMPORTED_MODULE_0___default()(node,existingNode)){const strNode=nodeToString(node);const strExisting=nodeToString(existingNode);throw new Error(\"conflict between new node \".concat(strNode,\" and existing \").concat(strExisting));}}this._markModification();this._maybeCheckInvariants();return this;}/**\n   * Remove a node from the graph.\n   *\n   * If the node does not exist in the graph, no action is taken and no error\n   * is thrown. (This operation is idempotent.)\n   *\n   * Removing a node which is incident to some edges is allowed; such edges will\n   * become dangling edges. See the discussion of 'Dangling Edges' in the module docstring\n   * for details.\n   *\n   * Returns `this` for chaining.\n   */removeNode(a){NodeAddress.assertValid(a);this._nodes.delete(a);this._unreference(a);this._markModification();this._maybeCheckInvariants();return this;}/**\n   * Test whether there exists a Node corresponding to the given NodeAddress.\n   *\n   * This will return false for node addresses which are referenced by some\n   * edge, but not actually present in the graph.\n   */hasNode(a){NodeAddress.assertValid(a);const result=this._nodes.has(a);this._maybeCheckInvariants();return result;}/**\n   * Returns the Node matching a given NodeAddressT, if such a node exists,\n   * or undefined otherwise.\n   */node(address){NodeAddress.assertValid(address);const result=this._nodes.get(address);this._maybeCheckInvariants();return result;}/**\n   * Returns an iterator over all of the nodes in the graph.\n   *\n   * Optionally, the caller can provide a node prefix. If\n   * provided, the iterator will only contain nodes matching that\n   * prefix. See semantics of [Address.hasPrefix][1] for details.\n   *\n   * Clients must not modify the graph during iteration. If they do so, an\n   * error may be thrown at the iteration call site.\n   *\n   * Nodes are yielded in address-sorted order.\n   *\n   * [1]: https://github.com/sourcecred/sourcecred/blob/7c7fa2d83d4fd5ba38efb2b2f4e0244235ac1312/src/core/address.js#L74\n   */nodes(options){const prefix=options!=null?options.prefix:NodeAddress.empty;if(prefix==null){throw new Error(\"Invalid prefix: \".concat(String(prefix)));}const result=this._nodesIterator(this._modificationCount,prefix);this._maybeCheckInvariants();return result;}*_nodesIterator(initialModificationCount,prefix){for(const address of this._getOrder().nodeOrder){if(NodeAddress.hasPrefix(address,prefix)){const node=_util_null__WEBPACK_IMPORTED_MODULE_4__[\"get\"](this._nodes.get(address));this._checkForComodification(initialModificationCount);this._maybeCheckInvariants();yield node;}}this._checkForComodification(initialModificationCount);this._maybeCheckInvariants();}/**\n   * Add an edge to the graph.\n   *\n   * It is permitted to add an edge if its src or dst are not in the graph. See\n   * the discussion of 'Dangling Edges' in the module docstring for semantics.\n   *\n   * It is an error to add an edge if a distinct edge with the same address\n   * already exists in the graph (i.e., if the source or destination are\n   * different).\n   *\n   * Adding an edge that already exists to the graph is a no-op. (This\n   * operation is idempotent.)\n   *\n   * Returns `this` for chaining.\n   */addEdge(edge){NodeAddress.assertValid(edge.src,\"edge.src\");NodeAddress.assertValid(edge.dst,\"edge.dst\");EdgeAddress.assertValid(edge.address,\"edge.address\");this._reference(edge.src);this._reference(edge.dst);const existingEdge=this._edges.get(edge.address);if(existingEdge!=null){if(existingEdge.src!==edge.src||existingEdge.dst!==edge.dst||existingEdge.address!==edge.address||existingEdge.timestampMs!==edge.timestampMs){const strEdge=edgeToString(edge);const strExisting=edgeToString(existingEdge);throw new Error(\"conflict between new edge \".concat(strEdge,\" and existing \").concat(strExisting));}}else{this._edges.set(edge.address,edge);const{inEdges}=_util_null__WEBPACK_IMPORTED_MODULE_4__[\"get\"](this._incidentEdges.get(edge.dst));const{outEdges}=_util_null__WEBPACK_IMPORTED_MODULE_4__[\"get\"](this._incidentEdges.get(edge.src));inEdges.push(edge);outEdges.push(edge);}this._edges.set(edge.address,edge);this._markModification();this._maybeCheckInvariants();return this;}/**\n   * Remove an edge from the graph.\n   *\n   * Calling removeEdge on an address that does not correspond to any edge in\n   * the graph is a no-op. (This method is idempotent.)\n   *\n   * Returns `this` for chaining.\n   */removeEdge(address){EdgeAddress.assertValid(address);const edge=this._edges.get(address);if(edge!=null){this._edges.delete(address);const{inEdges}=_util_null__WEBPACK_IMPORTED_MODULE_4__[\"get\"](this._incidentEdges.get(edge.dst));const{outEdges}=_util_null__WEBPACK_IMPORTED_MODULE_4__[\"get\"](this._incidentEdges.get(edge.src));// TODO(perf): This is linear in the degree of the endpoints of the\n// edge. Consider storing in non-list form (e.g., `inEdges` and\n// `outEdges` fields in `_incidentEdges` could be `Set<EdgeAddressT>`).\n[inEdges,outEdges].forEach(edges=>{const index=edges.findIndex(edge=>edge.address===address);if(index===-1){const strAddress=EdgeAddress.toString(address);throw new Error(\"Invariant violation when removing edge@\".concat(strAddress));}edges.splice(index,1);});this._unreference(edge.src);this._unreference(edge.dst);}this._markModification();this._maybeCheckInvariants();return this;}/**\n   * Test whether the graph contains an edge with the given address.\n   */hasEdge(address){EdgeAddress.assertValid(address);const result=this._edges.has(address);this._maybeCheckInvariants();return result;}/**\n   * Test whether there is a dangling edge at the given address.\n   *\n   * Returns true if the edge is present, and is dangling.\n   * Returns false if the edge is present, and is not dangling.\n   * Returns undefined if the edge is not present.\n   *\n   * See the module docstring for more details on dangling edges.\n   */isDanglingEdge(address){EdgeAddress.assertValid(address);const edge=this.edge(address);let result;if(edge!=null){const{src,dst}=edge;result=!this.hasNode(src)||!this.hasNode(dst);}this._maybeCheckInvariants();return result;}/**\n   * Returns the Edge matching a given EdgeAddressT, if such an edge exists, or\n   * null otherwise.\n   */edge(address){EdgeAddress.assertValid(address);const result=this._edges.get(address);this._maybeCheckInvariants();return result;}/**\n   * Returns an iterator over edges in the graph, optionally filtered by edge\n   * address prefix, source address prefix, and/or destination address prefix.\n   *\n   * The caller must pass an options object with a boolean field `showDangling`,\n   * which determines whether dangling edges will be included in the results.\n   * The caller may also pass fields `addressPrefix`, `srcPrefix`, and `dstPrefix`\n   * to perform prefix-based address filtering of edges that are returned.\n   * (See the module docstring for more context on dangling edges.)\n   *\n   * Suppose that you want to find every edge that represents authorship by a\n   * user. If all authorship edges have the `AUTHORS_EDGE_PREFIX` prefix, and\n   * all user nodes have the `USER_NODE_PREFIX` prefix, then you could call:\n   *\n   * graph.edges({\n   *  showDangling: true,  // or false, irrelevant for this example\n   *  addressPrefix: AUTHORS_EDGE_PREFIX,\n   *  srcPrefix: USER_NODE_PREFIX,\n   * });\n   *\n   * In this example, as `dstPrefix` was left unset, it will default to\n   * `NodeAddress.empty`, which is a prefix of every node address.\n   *\n   * Clients must not modify the graph during iteration. If they do so, an\n   * error may be thrown at the iteration call site.\n   *\n   * The edges are yielded in sorted address order.\n   */edges(options){if(options==null){throw new Error(\"Options are required for Graph.edges\");}const{showDangling}=options;const addressPrefix=_util_null__WEBPACK_IMPORTED_MODULE_4__[\"orElse\"](options.addressPrefix,EdgeAddress.empty);const srcPrefix=_util_null__WEBPACK_IMPORTED_MODULE_4__[\"orElse\"](options.srcPrefix,NodeAddress.empty);const dstPrefix=_util_null__WEBPACK_IMPORTED_MODULE_4__[\"orElse\"](options.dstPrefix,NodeAddress.empty);const result=this._edgesIterator(this._modificationCount,showDangling,addressPrefix,srcPrefix,dstPrefix);this._maybeCheckInvariants();return result;}*_edgesIterator(initialModificationCount,showDangling,addressPrefix,srcPrefix,dstPrefix){for(const address of this._getOrder().edgeOrder){const edge=_util_null__WEBPACK_IMPORTED_MODULE_4__[\"get\"](this._edges.get(address));if((showDangling||this.isDanglingEdge(edge.address)===false)&&EdgeAddress.hasPrefix(edge.address,addressPrefix)&&NodeAddress.hasPrefix(edge.src,srcPrefix)&&NodeAddress.hasPrefix(edge.dst,dstPrefix)){this._checkForComodification(initialModificationCount);this._maybeCheckInvariants();yield edge;}}this._checkForComodification(initialModificationCount);this._maybeCheckInvariants();}/**\n   * Find the `Neighbors` that are incident to a chosen root node.\n   *\n   * A `Neighbor` contains an edge that is incident to the root,\n   * and the node at the other endpoint of the edge. This may be\n   * either the source or destination of the edge, depending on whether the\n   * edge is an in-edge or an out-edge from the perspective of the root. For\n   * convenience, a `Neighbor` is thus an object that includes both the edge\n   * and the adjacent node.\n   *\n   * Every non-dangling edge incident to the root corresponds to exactly one\n   * neighbor, but note that multiple neighbors may have the same `node` in the\n   * case that there are multiple edges with the same source and destination.\n   *\n   * Callers to `neighbors` must provide `NeighborsOptions` as follows:\n   *\n   * - direction: one of Direction.IN, direction.OUT, or Direction.ANY.\n   *   - Direction.IN finds neigbhors where root is the destination of the\n   *     edge.\n   *   - Direction.OUT finds neigbhors where root is the source of the edge.\n   *   - Direction.ANY finds neigbhors where root is the source or destination\n   *     of the edge.\n   *\n   * - nodePrefix: A NodeAddressT to use as a prefix filter for the adjacent node.\n   *   If you want all nodes, use `NodeAddress`.empty.\n   *\n   * - edgePrefix: An EdgeAddressT to use as a prefix filter for the edge.\n   *   If you want all edges, use `EdgeAddress`.empty.\n   *\n   * Calling `neighbors` on a node that is not present in the graph is an error.\n   *\n   * If the root node has an edge for which it is both the source and the\n   * destination (a loop edge), there will be one `Neighbor` with the root node\n   * and the loop edge.\n   *\n   * No `Neighbors` will be created for dangling edges, as such edges do not\n   * correspond to any Node in the graph.\n   *\n   * Clients must not modify the graph during iteration. If they do so, an\n   * error may be thrown at the iteration call site. The iteration order is\n   * undefined.\n   */neighbors(node,options){if(!this.hasNode(node)){throw new Error(\"Node does not exist: \".concat(NodeAddress.toString(node)));}const result=this._neighbors(node,options,this._modificationCount);this._maybeCheckInvariants();return result;}*_neighbors(node,options,initialModificationCount){const nodeFilter=n=>NodeAddress.hasPrefix(n,options.nodePrefix);const edgeFilter=e=>EdgeAddress.hasPrefix(e,options.edgePrefix);const direction=options.direction;const adjacencies=[];if(direction===Direction.IN||direction===Direction.ANY){const{inEdges}=_util_null__WEBPACK_IMPORTED_MODULE_4__[\"get\"](this._incidentEdges.get(node));adjacencies.push({edges:inEdges,direction:\"IN\"});}if(direction===Direction.OUT||direction===Direction.ANY){const{outEdges}=_util_null__WEBPACK_IMPORTED_MODULE_4__[\"get\"](this._incidentEdges.get(node));adjacencies.push({edges:outEdges,direction:\"OUT\"});}for(const adjacency of adjacencies){for(const edge of adjacency.edges){if(direction===Direction.ANY&&adjacency.direction===\"IN\"){if(edge.src===edge.dst){continue;// don't yield loop edges twice.\n}}const neighborNodeAddress=adjacency.direction===\"IN\"?edge.src:edge.dst;const neighborNode=this.node(neighborNodeAddress);if(nodeFilter(neighborNodeAddress)&&edgeFilter(edge.address)&&neighborNode!=null){this._checkForComodification(initialModificationCount);this._maybeCheckInvariants();yield{edge,node:neighborNode};}}}this._checkForComodification(initialModificationCount);this._maybeCheckInvariants();}/**\n   * Checks whether this graph is equal to another graph.\n   *\n   * Two Graphs are considered equal if they have identical sets of nodes\n   * and edges. Insertion order is irrelevant.\n   *\n   * Runs in time `O(n + e)`, where `n` is the number of nodes and `e` is the\n   * number of edges.\n   */equals(that){if(!(that instanceof Graph)){throw new Error(\"Expected Graph, got \".concat(String(that)));}const result=lodash_isequal__WEBPACK_IMPORTED_MODULE_0___default()(this._nodes,that._nodes)&&lodash_isequal__WEBPACK_IMPORTED_MODULE_0___default()(this._edges,that._edges);this._maybeCheckInvariants();return result;}/**\n   * Produce a copy of this graph.\n   *\n   * The copy is equal to the original, but distinct, so that they may be\n   * modified independently.\n   */copy(){const result=Graph.merge([this]);this._maybeCheckInvariants();return result;}/**\n   * Serialize a Graph into a plain JavaScript object.\n   */toJSON(){// Unlike Array.from(this.nodes()).map((x) => x.address), this will include\n// node references. Including node references is necessary so that we can\n// index edges' src and dst consistently, even for dangling edges.\nconst sortedNodeAddresses=Array.from(this._incidentEdges.keys()).sort();const nodeAddressToSortedIndex=new Map();sortedNodeAddresses.forEach((address,i)=>{nodeAddressToSortedIndex.set(address,i);});const sortedEdges=Array.from(this.edges({showDangling:true}));const indexedEdges=sortedEdges.map((_ref)=>{let{src,dst,address,timestampMs}=_ref;const srcIndex=_util_null__WEBPACK_IMPORTED_MODULE_4__[\"get\"](nodeAddressToSortedIndex.get(src));const dstIndex=_util_null__WEBPACK_IMPORTED_MODULE_4__[\"get\"](nodeAddressToSortedIndex.get(dst));return{srcIndex,dstIndex,address:EdgeAddress.toParts(address),timestampMs};});const sortedNodes=Array.from(this.nodes());const indexedNodes=sortedNodes.map((_ref2)=>{let{address,description,timestampMs}=_ref2;const index=_util_null__WEBPACK_IMPORTED_MODULE_4__[\"get\"](nodeAddressToSortedIndex.get(address));return{index,description,timestampMs};});const rawJSON={sortedNodeAddresses:sortedNodeAddresses.map(x=>NodeAddress.toParts(x)),edges:indexedEdges,nodes:indexedNodes};const result=Object(_util_compat__WEBPACK_IMPORTED_MODULE_3__[\"toCompat\"])(COMPAT_INFO,rawJSON);this._maybeCheckInvariants();return result;}/**\n   * Deserializes a GraphJSON into a new Graph.\n   */static fromJSON(compatJson){const{nodes:nodesJSON,edges:edgesJSON,sortedNodeAddresses:sortedNodeAddressesJSON}=Object(_util_compat__WEBPACK_IMPORTED_MODULE_3__[\"fromCompat\"])(COMPAT_INFO,compatJson);const sortedNodeAddresses=sortedNodeAddressesJSON.map(NodeAddress.fromParts);const result=new Graph();nodesJSON.forEach(j=>{const n={address:sortedNodeAddresses[j.index],description:j.description,timestampMs:j.timestampMs};result.addNode(n);});edgesJSON.forEach((_ref3)=>{let{address,srcIndex,dstIndex,timestampMs}=_ref3;const src=sortedNodeAddresses[srcIndex];const dst=sortedNodeAddresses[dstIndex];result.addEdge({address:EdgeAddress.fromParts(address),src:src,dst:dst,timestampMs});});return result;}/**\n   * Compute the union of the given graphs. The result is a new graph that has\n   * all of the nodes and all of the edges from all the provided graphs.\n   *\n   * If two of the given graphs have edges with the same address, the edges\n   * must be equal (i.e. must have the same source and destination in each\n   * graph). If this is not the case, an error will be thrown.\n   *\n   * Example usage:\n   *\n   * const g1 = new Graph().addNode(a).addNode(b).addEdge(e);\n   * const g2 = new Graph().addNode(b).addNode(c).addEdge(f);\n   * const g3 = Graph.merge([g1, g2]);\n   * Array.from(g3.nodes()).length;  // 3\n   * Array.from(g3.edges()).length;  // 2\n   * const g1 = new Graph().addNode(a).addNode(b).addEdge(x);\n   * const g2 = new Graph().addNode(c);\n   * const g3 = Graph.merge([g1, g2]);\n   *\n   * The newly created graph is a separate instance from any of the input graphs,\n   * and may be mutated independently.\n   */static merge(graphs){const result=new Graph();for(const graph of graphs){for(const node of graph.nodes()){result.addNode(node);}for(const edge of graph.edges({showDangling:true})){result.addEdge(edge);}}return result;}/**\n   * Create a new graph, in which some nodes have been contracted together.\n   *\n   * contractNodes takes a list of NodeContractions, each of which specifies a\n   * replacement node, and a list of old node addresses to map onto the new\n   * node. A new graph will be returned where the new node is added, none of\n   * the old nodes are present, and every edge incident to one of the old nodes\n   * has been re-written so that it is incident to the new node instead.\n   *\n   * If the same node addresses is \"old\" for several contractions, all incident\n   * edges will be re-written to connect to whichever contraction came last.\n   *\n   * If the replacement node is present in the graph, no error will be thrown,\n   * provided that the replacement node is consistent with the one in the graph.\n   *\n   * If there is a \"chain\" of remaps (i.e. a->b and b->c), then an error will\n   * be thrown, as support for chaining has not yet been implemented.\n   *\n   * The original Graph is not mutated.\n   *\n   * contractNodes runs in O(n+e+k), where `n` is the number of nodes, `e` is the\n   * number of edges, and `k` is the number of contractions. If needed, we can\n   * improve the peformance by mutating the original graph instead of creating\n   * a new one.\n   */contractNodes(contractions){const remap=new Map();const replacements=new Set();const contracted=new Graph();for(const{old,replacement}of contractions){for(const addr of old){if(replacements.has(addr)){throw new Error(\"Chained contractions are not supported: \".concat(NodeAddress.toString(addr)));}remap.set(addr,replacement.address);}replacements.add(replacement.address);contracted.addNode(replacement);}for(const node of this.nodes()){if(!remap.has(node.address)){contracted.addNode(node);}}for(const edge of this.edges({showDangling:true})){const src=_util_null__WEBPACK_IMPORTED_MODULE_4__[\"orElse\"](remap.get(edge.src),edge.src);const dst=_util_null__WEBPACK_IMPORTED_MODULE_4__[\"orElse\"](remap.get(edge.dst),edge.dst);const newEdge=_objectSpread({},edge,{src,dst});contracted.addEdge(newEdge);}return contracted;}checkInvariants(){if(this._invariantsLastChecked.when!==this._modificationCount){let failure=null;try{this._checkInvariants();}catch(e){failure=e.message;}finally{this._invariantsLastChecked={when:this._modificationCount,failure};}}if(this._invariantsLastChecked.failure!=null){throw new Error(this._invariantsLastChecked.failure);}}_checkInvariants(){// Definition. A node `n` is in the graph if `n` is deep-equal to\n// `_nodes.get(n.address)`.\n//\n// Definition. An edge `e` is in the graph if `e` is deep-equal to\n// `_edges.get(e.address)`.\n//\n// Definition. A *logical value* is an equivalence class of ECMAScript\n// values modulo deep equality (or, from context, an element of such a\n// class).\n// Invariant 1. A node address `na` is 'referenced' if `_incidentEdges.has(na)`.\n// 1.1 If a node is in the graph, then it is referenced by its address.\n// 1.2 If a node has any incident edge, then it is referenced.\n// 1.3 If a node is not in the graph and does not have incident edges, then\n// it is not referenced.\nconst referencedNodesEncountered=new Set();// 1.1\nfor(const[address,node]of this._nodes){if(node.address!==address){throw new Error(\"bad node address for \".concat(NodeAddress.toString(address)));}if(!this._incidentEdges.has(address)){throw new Error(\"missing incident-edges for \".concat(NodeAddress.toString(address)));}referencedNodesEncountered.add(address);}// 1.2\nfor(const edge of this._edges.values()){if(!this._incidentEdges.has(edge.src)){throw new Error(\"missing incident-edges for src of: \".concat(edgeToString(edge)));}referencedNodesEncountered.add(edge.src);if(!this._incidentEdges.has(edge.dst)){throw new Error(\"missing incident-edges for dst of: \".concat(edgeToString(edge)));}referencedNodesEncountered.add(edge.dst);}// Check 1.3 by implication: for every address in\n// referencedNodesEncountered, we've explicitly checked that it is present\n// in _incidentEdges.\n//\n// Therefore, if the number of keys in _incidentEdges differs from the\n// number of elements in referencedNodesEncountered, it must be because\n// some elements in _incidentEdges were not present in\n// referencedNodesEncountered, which means that they did not correspond to\n// a node in the graph and did not have incident edges.\nconst numIncidentEntries=Array.from(this._incidentEdges.keys()).length;if(numIncidentEntries!==referencedNodesEncountered.size){throw new Error(\"extra addresses in incident-edges\");}// Invariant 2. For an edge address `a`, if `_edges.has(a)` and\n// `_edges.get(a) === e`, then:\n//  1. `e.address` equals `a`;\n//  2. `e.src` is referenced;\n//  3. `e.dst` is referenced;\n//  4. `_incidentEdges.get(e.dst).inEdges` contains `e`; and\n//  5. `_incidentEdges.get(e.src).outEdges` contains `e`.\n//\n// 2.2 and 2.3 are implied by 2.4 and 2.5 respectively (as a node's address\n// being available in _incidentEdges means that it is referenced). So we may\n// ignore them.\n//\n// We check 2.1 here, and check 2.4 and 2.5 later for improved performance.\nfor(const[address,edge]of this._edges.entries()){if(edge.address!==address){throw new Error(\"bad edge address: \".concat(edgeToString(edge),\" does not match \").concat(address));}}// Invariant 3. Suppose that `_incidentEdges.has(n)` and, let `es` be\n// `_incidentEdges.get(n).inEdges`. Then\n//  1. `es` contains any logical value at most once;\n//  2. if `es` contains `e`, then `e` is in the graph; and\n//  3. if `es` contains `e`, then `e.dst === n`.\n//\n// Invariant 4. Suppose that `_incidentEdges.has(n)` and, let `es` be\n// `_incidentEdges.get(n).outEdges`. Then\n//  1. `es` contains any logical value at most once;\n//  2. if `es` contains `e`, then `e` is in the graph; and\n//  3. if `es` contains `e`, then `e.src === n`.\n//\n// Note that Invariant 3.1 is equivalent to the following:\n//\n//     Invariant 3.1*. If `a` is an address, then there is at most\n//     one index `i` such that `es[i].address` is `a`.\n//\n// It is immediate that 3.1* implies 3.1. To see that 3.1 implies\n// 3.1*, suppose that `i` and `j` are such that `es[i].address` and\n// `es[j].address` are both `a`. Then, by Invariant 3.2, each of\n// `es[i]` and `es[j]` is in the graph, so each is deep-equal to\n// `_edges.get(a)`. Therefore, `es[i]` and `es[j]` are deep-equal to\n// each other. By 3.1, `es` contains a logical value at most once,\n// so `i` must be equal to `j`.\n//\n// Therefore, it is valid to verify that 3.1*, which we will do. The\n// same logic of course applies to Invariant 4.1.\nconst inEdgesSeen=new Set();const outEdgesSeen=new Set();const incidentEntries=Array.from(this._incidentEdges.entries());for(const{seen,entries,baseNodeAccessor,kind}of[{seen:inEdgesSeen,entries:incidentEntries.map((_ref4)=>{let[a,{inEdges}]=_ref4;return[a,inEdges];}),baseNodeAccessor:e=>e.dst,kind:\"in-edge\"},{seen:outEdgesSeen,entries:incidentEntries.map((_ref5)=>{let[a,{outEdges}]=_ref5;return[a,outEdges];}),baseNodeAccessor:e=>e.src,kind:\"out-edge\"}]){for(const[base,edges]of entries){for(const edge of edges){// 3.1/4.1\nif(seen.has(edge.address)){throw new Error(\"duplicate \".concat(kind,\": \").concat(edgeToString(edge)));}seen.add(edge.address);const expected=this._edges.get(edge.address);// 3.2/4.2\nif(!lodash_isequal__WEBPACK_IMPORTED_MODULE_0___default()(edge,expected)){if(expected==null){throw new Error(\"spurious \".concat(kind,\": \").concat(edgeToString(edge)));}else{const vs=\"\".concat(edgeToString(edge),\" vs. \").concat(edgeToString(expected));throw new Error(\"bad \".concat(kind,\": \").concat(vs));}}// 3.3/4.3\nconst expectedBase=baseNodeAccessor(edge);if(base!==baseNodeAccessor(edge)){throw new Error(\"bad \".concat(kind,\": \").concat(edgeToString(edge),\" should be \")+\"should be anchored at \".concat(NodeAddress.toString(expectedBase)));}}}}// We now return to check 2.4 and 2.5, with the help of the\n// structures that we have built up in checking Invariants 3 and 4.\nfor(const edge of this._edges.values()){// That `_incidentEdges.get(n).inEdges` contains `e` for some `n` is\n// sufficient to show that `_incidentEdges.get(e.dst).inEdges` contains\n// `e`: if `n` were something other than `e.dst`, then we would have a\n// failure of invariant 3.3, which would have been caught earlier.\n// Likewise for outEdges.\nif(!inEdgesSeen.has(edge.address)){throw new Error(\"missing in-edge: \".concat(edgeToString(edge)));}if(!outEdgesSeen.has(edge.address)){throw new Error(\"missing out-edge: \".concat(edgeToString(edge)));}}}_maybeCheckInvariants(){if(false){}}}/**\n * Convert a node into a human readable string.\n *\n * The precise behavior is an implementation detail and subject to change.\n */function nodeToString(node){const address=NodeAddress.toString(node.address);return\"{address: \".concat(address,\"}\");}/**\n * Convert an edge into a human readable string.\n *\n * The precise behavior is an implementation detail and subject to change.\n */function edgeToString(edge){const address=EdgeAddress.toString(edge.address);const src=NodeAddress.toString(edge.src);const dst=NodeAddress.toString(edge.dst);return\"{address: \".concat(address,\", src: \").concat(src,\", dst: \").concat(dst,\", timestampMs: \").concat(edge.timestampMs,\"}\");}/**\n * Convert an edge to an object whose fields are human-readable.\n * This is useful for storing edges in human-readable formats that\n * should not include NUL characters, such as Jest snapshots.\n */function edgeToStrings(edge){return{address:EdgeAddress.toString(edge.address),src:NodeAddress.toString(edge.src),dst:NodeAddress.toString(edge.dst),timestampMs:edge.timestampMs};}function edgeToParts(edge){const addressParts=EdgeAddress.toParts(edge.address);const srcParts=NodeAddress.toParts(edge.src);const dstParts=NodeAddress.toParts(edge.dst);const timestampMs=edge.timestampMs;return{addressParts,srcParts,dstParts,timestampMs};}\n\n//# sourceURL=webpack:///./src/core/graph.js?");

/***/ }),

/***/ "./src/core/trie.js":
/*!**************************!*\
  !*** ./src/core/trie.js ***!
  \**************************/
/*! exports provided: NodeTrie, EdgeTrie */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"NodeTrie\", function() { return NodeTrie; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"EdgeTrie\", function() { return EdgeTrie; });\n/* harmony import */ var _graph__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./graph */ \"./src/core/graph.js\");\n/* harmony import */ var _util_null__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/null */ \"./src/util/null.js\");\nfunction _defineProperty(obj,key,value){if(key in obj){Object.defineProperty(obj,key,{value:value,enumerable:true,configurable:true,writable:true});}else{obj[key]=value;}return obj;}const EMPTY_ENTRY_SYMBOL=Symbol(\"EMPTY\");class BaseTrie{/**\n   * Create an empty trie backed by the given address module.\n   */constructor(m){_defineProperty(this,\"addressModule\",void 0);_defineProperty(this,\"entry\",void 0);this.addressModule=m;this.entry={value:EMPTY_ENTRY_SYMBOL,map:new Map()};}/**\n   * Add key `k` to this trie with value `v`. Return `this`.\n   */add(k,val){const parts=this.addressModule.toParts(k);let entry=this.entry;for(const part of parts){if(!entry.map.has(part)){entry.map.set(part,{map:new Map(),value:EMPTY_ENTRY_SYMBOL});}entry=_util_null__WEBPACK_IMPORTED_MODULE_1__[\"get\"](entry.map.get(part));}if(entry.value!==EMPTY_ENTRY_SYMBOL){throw new Error(\"Tried to overwrite entry at \".concat(this.addressModule.toString(k)));}entry.value=val;return this;}/**\n   * Get the values in this trie along the path to `k`.\n   *\n   * More specifically, this method has the following observable\n   * behavior. Let `inits` be the list of all prefixes of `k`, ordered\n   * by length (shortest to longest). Observe that the length of `inits`\n   * is `n + 1`, where `n` is the number of parts of `k`; `inits` begins\n   * with the empty address and ends with `k` itself. Initialize the\n   * result to an empty array. For each prefix `p` in `inits`, if `p`\n   * was added to this trie with value `v`, then append `v` to\n   * `result`. Return `result`.\n   */get(k){const parts=this.addressModule.toParts(k);const result=[];let entry=this.entry;// nb: if parts has length `n`, there are `n+1` opportunities to add a\n// value to the resultant array, which is correct as there may be `n+1`\n// appropriate values to return: one for each part, and another for the\n// empty address.\nfor(const part of parts){if(entry.value!==EMPTY_ENTRY_SYMBOL){const value=entry.value;result.push(value);}const tmpEntry=entry.map.get(part);if(tmpEntry==null){return result;}else{entry=tmpEntry;}}if(entry.value!==EMPTY_ENTRY_SYMBOL){const value=entry.value;result.push(value);}return result;}/**\n   * Get the last stored value `v` in the path to key `k`.\n   * Returns undefined if no value is available.\n   */getLast(k){const path=this.get(k);return path[path.length-1];}}class NodeTrie extends BaseTrie{constructor(){super(_graph__WEBPACK_IMPORTED_MODULE_0__[\"NodeAddress\"]);}}class EdgeTrie extends BaseTrie{constructor(){super(_graph__WEBPACK_IMPORTED_MODULE_0__[\"EdgeAddress\"]);}}\n\n//# sourceURL=webpack:///./src/core/trie.js?");

/***/ }),

/***/ "./src/plugins/discourse/address.js":
/*!******************************************!*\
  !*** ./src/plugins/discourse/address.js ***!
  \******************************************/
/*! exports provided: topicAddress, postAddress, userAddress */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"topicAddress\", function() { return topicAddress; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"postAddress\", function() { return postAddress; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"userAddress\", function() { return userAddress; });\n/* harmony import */ var _core_graph__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/graph */ \"./src/core/graph.js\");\n/* harmony import */ var _declaration__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./declaration */ \"./src/plugins/discourse/declaration.js\");\nfunction topicAddress(serverUrl,id){return _core_graph__WEBPACK_IMPORTED_MODULE_0__[\"NodeAddress\"].append(_declaration__WEBPACK_IMPORTED_MODULE_1__[\"topicNodeType\"].prefix,serverUrl,String(id));}function postAddress(serverUrl,id){return _core_graph__WEBPACK_IMPORTED_MODULE_0__[\"NodeAddress\"].append(_declaration__WEBPACK_IMPORTED_MODULE_1__[\"postNodeType\"].prefix,serverUrl,String(id));}function userAddress(serverUrl,username){return _core_graph__WEBPACK_IMPORTED_MODULE_0__[\"NodeAddress\"].append(_declaration__WEBPACK_IMPORTED_MODULE_1__[\"userNodeType\"].prefix,serverUrl,username);}\n\n//# sourceURL=webpack:///./src/plugins/discourse/address.js?");

/***/ }),

/***/ "./src/plugins/discourse/declaration.js":
/*!**********************************************!*\
  !*** ./src/plugins/discourse/declaration.js ***!
  \**********************************************/
/*! exports provided: nodePrefix, edgePrefix, topicNodeType, postNodeType, userNodeType, topicContainsPostEdgeType, postRepliesEdgeType, authorsTopicEdgeType, authorsPostEdgeType, likesEdgeType, referencesPostEdgeType, referencesTopicEdgeType, referencesUserEdgeType, declaration */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"nodePrefix\", function() { return nodePrefix; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"edgePrefix\", function() { return edgePrefix; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"topicNodeType\", function() { return topicNodeType; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"postNodeType\", function() { return postNodeType; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"userNodeType\", function() { return userNodeType; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"topicContainsPostEdgeType\", function() { return topicContainsPostEdgeType; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"postRepliesEdgeType\", function() { return postRepliesEdgeType; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"authorsTopicEdgeType\", function() { return authorsTopicEdgeType; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"authorsPostEdgeType\", function() { return authorsPostEdgeType; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"likesEdgeType\", function() { return likesEdgeType; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"referencesPostEdgeType\", function() { return referencesPostEdgeType; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"referencesTopicEdgeType\", function() { return referencesTopicEdgeType; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"referencesUserEdgeType\", function() { return referencesUserEdgeType; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"declaration\", function() { return declaration; });\n/* harmony import */ var deep_freeze__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! deep-freeze */ \"deep-freeze\");\n/* harmony import */ var deep_freeze__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(deep_freeze__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _core_graph__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../core/graph */ \"./src/core/graph.js\");\nconst nodePrefix=_core_graph__WEBPACK_IMPORTED_MODULE_1__[\"NodeAddress\"].fromParts([\"sourcecred\",\"discourse\"]);const edgePrefix=_core_graph__WEBPACK_IMPORTED_MODULE_1__[\"EdgeAddress\"].fromParts([\"sourcecred\",\"discourse\"]);const topicNodeType=deep_freeze__WEBPACK_IMPORTED_MODULE_0___default()({name:\"Topic\",pluralName:\"Topics\",prefix:_core_graph__WEBPACK_IMPORTED_MODULE_1__[\"NodeAddress\"].append(nodePrefix,\"topic\"),defaultWeight:2,description:\"A topic (or post-container) in a Discourse instance. Every topic has at least one post.\"});const postNodeType=deep_freeze__WEBPACK_IMPORTED_MODULE_0___default()({name:\"Post\",pluralName:\"Posts\",prefix:_core_graph__WEBPACK_IMPORTED_MODULE_1__[\"NodeAddress\"].append(nodePrefix,\"post\"),defaultWeight:1,description:\"A post in some topic in a Discourse instance.\"});const userNodeType=deep_freeze__WEBPACK_IMPORTED_MODULE_0___default()({name:\"User\",pluralName:\"Users\",prefix:_core_graph__WEBPACK_IMPORTED_MODULE_1__[\"NodeAddress\"].append(nodePrefix,\"user\"),defaultWeight:1,description:\"A user account on a particular Discourse instance.\"});const topicContainsPostEdgeType=deep_freeze__WEBPACK_IMPORTED_MODULE_0___default()({forwardName:\"contains post\",backwardName:\"is contained by topic\",prefix:_core_graph__WEBPACK_IMPORTED_MODULE_1__[\"EdgeAddress\"].append(edgePrefix,\"topicContainsPost\"),defaultWeight:{forwards:1/16,backwards:1/4},description:\"Connects a topic to the posts that it contains.\"});const postRepliesEdgeType=deep_freeze__WEBPACK_IMPORTED_MODULE_0___default()({forwardName:\"post is reply to\",backwardName:\"post replied to by\",prefix:_core_graph__WEBPACK_IMPORTED_MODULE_1__[\"EdgeAddress\"].append(edgePrefix,\"replyTo\"),defaultWeight:{forwards:1,backwards:1/16},description:\"Connects a post to the post that it is a reply to.\"});const authorsTopicEdgeType=deep_freeze__WEBPACK_IMPORTED_MODULE_0___default()({forwardName:\"authors topic\",backwardName:\"topic is authored by\",prefix:_core_graph__WEBPACK_IMPORTED_MODULE_1__[\"EdgeAddress\"].append(edgePrefix,\"authors\",\"topic\"),defaultWeight:{forwards:1/4,backwards:1},description:\"Connects an author to a topic they created.\"});const authorsPostEdgeType=deep_freeze__WEBPACK_IMPORTED_MODULE_0___default()({forwardName:\"authors post\",backwardName:\"post is authored by\",prefix:_core_graph__WEBPACK_IMPORTED_MODULE_1__[\"EdgeAddress\"].append(edgePrefix,\"authors\",\"post\"),defaultWeight:{forwards:1/4,backwards:1},description:\"Connects an author to a post they've created.\"});const likesEdgeType=deep_freeze__WEBPACK_IMPORTED_MODULE_0___default()({forwardName:\"likes\",backwardName:\"is liked by\",prefix:_core_graph__WEBPACK_IMPORTED_MODULE_1__[\"EdgeAddress\"].append(edgePrefix,\"likes\"),defaultWeight:{forwards:1,backwards:1/16},description:\"Connects a Discourse user to a post they liked.\"});const referencesPostEdgeType=deep_freeze__WEBPACK_IMPORTED_MODULE_0___default()({forwardName:\"references post\",backwardName:\"post is referenced by\",prefix:_core_graph__WEBPACK_IMPORTED_MODULE_1__[\"EdgeAddress\"].append(edgePrefix,\"references\",\"post\"),defaultWeight:{forwards:1/2,backwards:1/16},description:\"Connects a Discourse post to another post it referenced.\"});const referencesTopicEdgeType=deep_freeze__WEBPACK_IMPORTED_MODULE_0___default()({forwardName:\"references topic\",backwardName:\"topic is referenced by\",prefix:_core_graph__WEBPACK_IMPORTED_MODULE_1__[\"EdgeAddress\"].append(edgePrefix,\"references\",\"topic\"),defaultWeight:{forwards:1/2,backwards:1/16},description:\"Connects a Discourse post to a topic it referenced.\"});const referencesUserEdgeType=deep_freeze__WEBPACK_IMPORTED_MODULE_0___default()({forwardName:\"mentions\",backwardName:\"is mentioned by\",prefix:_core_graph__WEBPACK_IMPORTED_MODULE_1__[\"EdgeAddress\"].append(edgePrefix,\"references\",\"user\"),defaultWeight:{forwards:1/4,backwards:1/16},description:\"Connects a Discourse post to a user it mentions\"});const declaration=deep_freeze__WEBPACK_IMPORTED_MODULE_0___default()({name:\"Discourse\",nodePrefix,edgePrefix,nodeTypes:[userNodeType,topicNodeType,postNodeType],edgeTypes:[postRepliesEdgeType,authorsTopicEdgeType,authorsPostEdgeType,topicContainsPostEdgeType,likesEdgeType,referencesPostEdgeType,referencesTopicEdgeType,referencesUserEdgeType],userTypes:[userNodeType]});\n\n//# sourceURL=webpack:///./src/plugins/discourse/declaration.js?");

/***/ }),

/***/ "./src/plugins/git/nodes.js":
/*!**********************************!*\
  !*** ./src/plugins/git/nodes.js ***!
  \**********************************/
/*! exports provided: _gitAddress, COMMIT_TYPE, Prefix, fromRaw, toRaw */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"_gitAddress\", function() { return _gitAddress; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"COMMIT_TYPE\", function() { return COMMIT_TYPE; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Prefix\", function() { return Prefix; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fromRaw\", function() { return fromRaw; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"toRaw\", function() { return toRaw; });\n/* harmony import */ var deep_freeze__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! deep-freeze */ \"deep-freeze\");\n/* harmony import */ var deep_freeze__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(deep_freeze__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _core_graph__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../core/graph */ \"./src/core/graph.js\");\nconst GIT_PREFIX=_core_graph__WEBPACK_IMPORTED_MODULE_1__[\"NodeAddress\"].fromParts([\"sourcecred\",\"git\"]);function _gitAddress(){for(var _len=arguments.length,parts=new Array(_len),_key=0;_key<_len;_key++){parts[_key]=arguments[_key];}return _core_graph__WEBPACK_IMPORTED_MODULE_1__[\"NodeAddress\"].append(GIT_PREFIX,...parts);}const COMMIT_TYPE=\"COMMIT\";const Prefix=deep_freeze__WEBPACK_IMPORTED_MODULE_0___default()({base:GIT_PREFIX,commit:_gitAddress(COMMIT_TYPE)});function fromRaw(x){function fail(){return new Error(\"Bad address: \".concat(_core_graph__WEBPACK_IMPORTED_MODULE_1__[\"NodeAddress\"].toString(x)));}if(!_core_graph__WEBPACK_IMPORTED_MODULE_1__[\"NodeAddress\"].hasPrefix(x,GIT_PREFIX)){throw fail();}const[_unused_sc,_unused_git,_type,...rest]=_core_graph__WEBPACK_IMPORTED_MODULE_1__[\"NodeAddress\"].toParts(x);const type=_type;switch(type){case\"COMMIT\":{if(rest.length!==1)throw fail();const[hash]=rest;return{type:COMMIT_TYPE,hash};}default:// eslint-disable-next-line no-unused-expressions\ntype;throw fail();}}function toRaw(x){switch(x.type){case COMMIT_TYPE:return _core_graph__WEBPACK_IMPORTED_MODULE_1__[\"NodeAddress\"].append(Prefix.commit,x.hash);default:throw new Error(\"Unexpected type \".concat(x.type));}}\n\n//# sourceURL=webpack:///./src/plugins/git/nodes.js?");

/***/ }),

/***/ "./src/plugins/github/bots.js":
/*!************************************!*\
  !*** ./src/plugins/github/bots.js ***!
  \************************************/
/*! exports provided: botSet */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"botSet\", function() { return botSet; });\n// TODO(#638): Allow projects to specify bots via configuration,\n// rather than depending on this single souce of truth\nfunction botSet(){return new Set([\"codecov\",\"codecov-io\",\"credbot\",\"facebook-github-bot\",\"gitcoinbot\",\"gitter-badger\",\"googlebot\",\"greenkeeper\",\"greenkeeperio-bot\",\"metamaskbot\",\"nodejs-github-bot\",\"stickler-ci\",\"tensorflow-gardener\",\"tensorflow-jenkins\",\"tensorflowbutler\",\"github-actions\",\"transifex-integration\"]);}\n\n//# sourceURL=webpack:///./src/plugins/github/bots.js?");

/***/ }),

/***/ "./src/plugins/github/declaration.js":
/*!*******************************************!*\
  !*** ./src/plugins/github/declaration.js ***!
  \*******************************************/
/*! exports provided: repoNodeType, userNodeType, declaration */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"repoNodeType\", function() { return repoNodeType; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"userNodeType\", function() { return userNodeType; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"declaration\", function() { return declaration; });\n/* harmony import */ var deep_freeze__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! deep-freeze */ \"deep-freeze\");\n/* harmony import */ var deep_freeze__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(deep_freeze__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _nodes__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./nodes */ \"./src/plugins/github/nodes.js\");\n/* harmony import */ var _edges__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./edges */ \"./src/plugins/github/edges.js\");\n/* harmony import */ var _util_dedent__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../util/dedent */ \"./src/util/dedent.js\");\nfunction _templateObject9(){const data=_taggedTemplateLiteral([\"    Connects a commit on GitHub to the corresponding raw Git commit.\\n  \"],[\"\\\\\\n    Connects a commit on GitHub to the corresponding raw Git commit.\\n  \"]);_templateObject9=function _templateObject9(){return data;};return data;}function _templateObject8(){const data=_taggedTemplateLiteral([\"    Connects users to posts to which they gave a \\uD83D\\uDE80 reaction.\\n  \"],[\"\\\\\\n    Connects users to posts to which they gave a \\uD83D\\uDE80 reaction.\\n  \"]);_templateObject8=function _templateObject8(){return data;};return data;}function _templateObject7(){const data=_taggedTemplateLiteral([\"    Connects users to posts to which they gave a \\uD83C\\uDF89 reaction.\\n  \"],[\"\\\\\\n    Connects users to posts to which they gave a \\uD83C\\uDF89 reaction.\\n  \"]);_templateObject7=function _templateObject7(){return data;};return data;}function _templateObject6(){const data=_taggedTemplateLiteral([\"    Connects users to posts to which they gave a \\uD83D\\uDC4D reaction.\\n  \"],[\"\\\\\\n    Connects users to posts to which they gave a \\uD83D\\uDC4D reaction.\\n  \"]);_templateObject6=function _templateObject6(){return data;};return data;}function _templateObject5(){const data=_taggedTemplateLiteral([\"    Connects users to posts to which they gave a \\u2764\\uFE0F reaction.\\n  \"],[\"\\\\\\n    Connects users to posts to which they gave a \\u2764\\uFE0F reaction.\\n  \"]);_templateObject5=function _templateObject5(){return data;};return data;}function _templateObject4(){const data=_taggedTemplateLiteral([\"    Connects a GitHub post to an entity that it references.\\n\\n    For example, if you write a GitHub issue comment that says \\\"thanks\\n    @username for pull #1337\\\", it will create references edges to both the user\\n    @username, and to pull #1337 in the same repository.\\n  \"],[\"\\\\\\n    Connects a GitHub post to an entity that it references.\\n\\n    For example, if you write a GitHub issue comment that says \\\"thanks\\n    @username for pull #1337\\\", it will create references edges to both the user\\n    @username, and to pull #1337 in the same repository.\\n  \"]);_templateObject4=function _templateObject4(){return data;};return data;}function _templateObject3(){const data=_taggedTemplateLiteral([\"    Connects a GitHub pull request to the Git commit that it merges.\\n  \"],[\"\\\\\\n    Connects a GitHub pull request to the Git commit that it merges.\\n  \"]);_templateObject3=function _templateObject3(){return data;};return data;}function _templateObject2(){const data=_taggedTemplateLiteral([\"    Connects a GitHub entity to its child entities.\\n\\n    For example, a Repository has Issues and Pull Requests as children, and a\\n    Pull Request has comments and reviews as children.\\n  \"],[\"\\\\\\n    Connects a GitHub entity to its child entities.\\n\\n    For example, a Repository has Issues and Pull Requests as children, and a\\n    Pull Request has comments and reviews as children.\\n  \"]);_templateObject2=function _templateObject2(){return data;};return data;}function _templateObject(){const data=_taggedTemplateLiteral([\"    Connects a GitHub account to a post that they authored.\\n\\n    Examples of posts include issues, pull requests, and comments.\\n  \"],[\"\\\\\\n    Connects a GitHub account to a post that they authored.\\n\\n    Examples of posts include issues, pull requests, and comments.\\n  \"]);_templateObject=function _templateObject(){return data;};return data;}function _taggedTemplateLiteral(strings,raw){if(!raw){raw=strings.slice(0);}return Object.freeze(Object.defineProperties(strings,{raw:{value:Object.freeze(raw)}}));}const repoNodeType=deep_freeze__WEBPACK_IMPORTED_MODULE_0___default()({name:\"Repository\",pluralName:\"Repositories\",prefix:_nodes__WEBPACK_IMPORTED_MODULE_1__[\"Prefix\"].repo,defaultWeight:4,description:\"NodeType for a GitHub repository\"});const issueNodeType=deep_freeze__WEBPACK_IMPORTED_MODULE_0___default()({name:\"Issue\",pluralName:\"Issues\",prefix:_nodes__WEBPACK_IMPORTED_MODULE_1__[\"Prefix\"].issue,defaultWeight:2,description:\"NodeType for a GitHub issue\"});const pullNodeType=deep_freeze__WEBPACK_IMPORTED_MODULE_0___default()({name:\"Pull request\",pluralName:\"Pull requests\",prefix:_nodes__WEBPACK_IMPORTED_MODULE_1__[\"Prefix\"].pull,defaultWeight:4,description:\"NodeType for a GitHub pull request\"});const reviewNodeType=deep_freeze__WEBPACK_IMPORTED_MODULE_0___default()({name:\"Pull request review\",pluralName:\"Pull request reviews\",prefix:_nodes__WEBPACK_IMPORTED_MODULE_1__[\"Prefix\"].review,defaultWeight:1,description:\"NodeType for a GitHub code review\"});const commentNodeType=deep_freeze__WEBPACK_IMPORTED_MODULE_0___default()({name:\"Comment\",pluralName:\"Comments\",prefix:_nodes__WEBPACK_IMPORTED_MODULE_1__[\"Prefix\"].comment,defaultWeight:1,description:\"NodeType for a GitHub comment\"});const commitNodeType=deep_freeze__WEBPACK_IMPORTED_MODULE_0___default()({name:\"Commit\",pluralName:\"Commits\",prefix:_nodes__WEBPACK_IMPORTED_MODULE_1__[\"Prefix\"].commit,defaultWeight:1,description:\"Represents a particular Git commit on GitHub, i.e. scoped to a particular repository\"});const userNodeType=deep_freeze__WEBPACK_IMPORTED_MODULE_0___default()({name:\"User\",pluralName:\"Users\",prefix:_nodes__WEBPACK_IMPORTED_MODULE_1__[\"Prefix\"].user,defaultWeight:1,description:\"NodeType for a GitHub user\"});const botNodeType=deep_freeze__WEBPACK_IMPORTED_MODULE_0___default()({name:\"Bot\",pluralName:\"Bots\",prefix:_nodes__WEBPACK_IMPORTED_MODULE_1__[\"Prefix\"].bot,defaultWeight:0.25,description:\"NodeType for a GitHub bot account\"});const nodeTypes=deep_freeze__WEBPACK_IMPORTED_MODULE_0___default()([repoNodeType,issueNodeType,pullNodeType,reviewNodeType,commentNodeType,commitNodeType,userNodeType,botNodeType]);const authorsEdgeType=deep_freeze__WEBPACK_IMPORTED_MODULE_0___default()({forwardName:\"authors\",backwardName:\"is authored by\",defaultWeight:{forwards:1/2,backwards:1},prefix:_edges__WEBPACK_IMPORTED_MODULE_2__[\"Prefix\"].authors,description:Object(_util_dedent__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(_templateObject())});const hasParentEdgeType=deep_freeze__WEBPACK_IMPORTED_MODULE_0___default()({forwardName:\"has parent\",backwardName:\"has child\",defaultWeight:{forwards:1,backwards:1/4},prefix:_edges__WEBPACK_IMPORTED_MODULE_2__[\"Prefix\"].hasParent,description:Object(_util_dedent__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(_templateObject2())});const mergedAsEdgeType=deep_freeze__WEBPACK_IMPORTED_MODULE_0___default()({forwardName:\"merges\",backwardName:\"is merged by\",defaultWeight:{forwards:1/2,backwards:1},prefix:_edges__WEBPACK_IMPORTED_MODULE_2__[\"Prefix\"].mergedAs,description:Object(_util_dedent__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(_templateObject3())});const referencesEdgeType=deep_freeze__WEBPACK_IMPORTED_MODULE_0___default()({forwardName:\"references\",backwardName:\"is referenced by\",defaultWeight:{forwards:1,backwards:0},prefix:_edges__WEBPACK_IMPORTED_MODULE_2__[\"Prefix\"].references,description:Object(_util_dedent__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(_templateObject4())});const reactsHeartEdgeType=deep_freeze__WEBPACK_IMPORTED_MODULE_0___default()({forwardName:\"reacted ❤️ to\",backwardName:\"got ❤️ from\",defaultWeight:{forwards:2,backwards:0},prefix:_edges__WEBPACK_IMPORTED_MODULE_2__[\"Prefix\"].reactsHeart,description:Object(_util_dedent__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(_templateObject5())});const reactsThumbsUpEdgeType=deep_freeze__WEBPACK_IMPORTED_MODULE_0___default()({forwardName:\"reacted 👍 to\",backwardName:\"got 👍 from\",defaultWeight:{forwards:1,backwards:0},prefix:_edges__WEBPACK_IMPORTED_MODULE_2__[\"Prefix\"].reactsThumbsUp,description:Object(_util_dedent__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(_templateObject6())});const reactsHoorayEdgeType=deep_freeze__WEBPACK_IMPORTED_MODULE_0___default()({forwardName:\"reacted 🎉 to\",backwardName:\"got 🎉 from\",defaultWeight:{forwards:4,backwards:0},prefix:_edges__WEBPACK_IMPORTED_MODULE_2__[\"Prefix\"].reactsHooray,description:Object(_util_dedent__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(_templateObject7())});const reactsRocketEdgeType=deep_freeze__WEBPACK_IMPORTED_MODULE_0___default()({forwardName:\"reacted 🚀 to\",backwardName:\"got 🚀 from\",defaultWeight:{forwards:1,backwards:0},prefix:_edges__WEBPACK_IMPORTED_MODULE_2__[\"Prefix\"].reactsRocket,description:Object(_util_dedent__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(_templateObject8())});const correspondsToCommitEdgeType=deep_freeze__WEBPACK_IMPORTED_MODULE_0___default()({forwardName:\"corresponds to Git commit\",backwardName:\"merged on GitHub as\",defaultWeight:{forwards:1,backwards:1},prefix:_edges__WEBPACK_IMPORTED_MODULE_2__[\"Prefix\"].correspondsToCommit,description:Object(_util_dedent__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(_templateObject9())});const edgeTypes=deep_freeze__WEBPACK_IMPORTED_MODULE_0___default()([authorsEdgeType,hasParentEdgeType,mergedAsEdgeType,referencesEdgeType,reactsThumbsUpEdgeType,reactsHeartEdgeType,reactsHoorayEdgeType,reactsRocketEdgeType,correspondsToCommitEdgeType]);const declaration=deep_freeze__WEBPACK_IMPORTED_MODULE_0___default()({name:\"GitHub\",nodePrefix:_nodes__WEBPACK_IMPORTED_MODULE_1__[\"Prefix\"].base,edgePrefix:_edges__WEBPACK_IMPORTED_MODULE_2__[\"Prefix\"].base,nodeTypes:nodeTypes,edgeTypes:edgeTypes,userTypes:[userNodeType]});\n\n//# sourceURL=webpack:///./src/plugins/github/declaration.js?");

/***/ }),

/***/ "./src/plugins/github/edges.js":
/*!*************************************!*\
  !*** ./src/plugins/github/edges.js ***!
  \*************************************/
/*! exports provided: AUTHORS_TYPE, MERGED_AS_TYPE, HAS_PARENT_TYPE, REFERENCES_TYPE, REACTS_TYPE, CORRESPONDS_TO_COMMIT_TYPE, Prefix, createEdge, fromRaw, toRaw */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"AUTHORS_TYPE\", function() { return AUTHORS_TYPE; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MERGED_AS_TYPE\", function() { return MERGED_AS_TYPE; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"HAS_PARENT_TYPE\", function() { return HAS_PARENT_TYPE; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"REFERENCES_TYPE\", function() { return REFERENCES_TYPE; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"REACTS_TYPE\", function() { return REACTS_TYPE; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CORRESPONDS_TO_COMMIT_TYPE\", function() { return CORRESPONDS_TO_COMMIT_TYPE; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Prefix\", function() { return Prefix; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"createEdge\", function() { return createEdge; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fromRaw\", function() { return fromRaw; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"toRaw\", function() { return toRaw; });\n/* harmony import */ var deep_freeze__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! deep-freeze */ \"deep-freeze\");\n/* harmony import */ var deep_freeze__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(deep_freeze__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _core_graph__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../core/graph */ \"./src/core/graph.js\");\n/* harmony import */ var _nodes__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./nodes */ \"./src/plugins/github/nodes.js\");\n/* harmony import */ var _git_nodes__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../git/nodes */ \"./src/plugins/git/nodes.js\");\n/* harmony import */ var _graphqlTypes__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./graphqlTypes */ \"./src/plugins/github/graphqlTypes.js\");\nconst AUTHORS_TYPE=\"AUTHORS\";const MERGED_AS_TYPE=\"MERGED_AS\";const HAS_PARENT_TYPE=\"HAS_PARENT\";const REFERENCES_TYPE=\"REFERENCES\";const REACTS_TYPE=\"REACTS\";// GitHub tracks its own notion of a commit, which has a particular\n// database id, is scoped to a particular repository, and has a canonical url\n// on GitHub. The CORRESPONDS_TO_COMMIT_TYPE edges connect the GitHub commits\n// to the corresponding Git commit.\nconst CORRESPONDS_TO_COMMIT_TYPE=\"CORRESPONDS_TO_COMMIT_TYPE\";const GITHUB_PREFIX=_core_graph__WEBPACK_IMPORTED_MODULE_1__[\"EdgeAddress\"].fromParts([\"sourcecred\",\"github\"]);function githubEdgeAddress(){for(var _len=arguments.length,parts=new Array(_len),_key=0;_key<_len;_key++){parts[_key]=arguments[_key];}return _core_graph__WEBPACK_IMPORTED_MODULE_1__[\"EdgeAddress\"].append(GITHUB_PREFIX,...parts);}const Prefix=deep_freeze__WEBPACK_IMPORTED_MODULE_0___default()({base:GITHUB_PREFIX,authors:githubEdgeAddress(AUTHORS_TYPE),mergedAs:githubEdgeAddress(MERGED_AS_TYPE),references:githubEdgeAddress(REFERENCES_TYPE),hasParent:githubEdgeAddress(HAS_PARENT_TYPE),reacts:githubEdgeAddress(REACTS_TYPE),reactsThumbsUp:githubEdgeAddress(REACTS_TYPE,_graphqlTypes__WEBPACK_IMPORTED_MODULE_4__[\"ReactionContent$Values\"].THUMBS_UP),reactsHeart:githubEdgeAddress(REACTS_TYPE,_graphqlTypes__WEBPACK_IMPORTED_MODULE_4__[\"ReactionContent$Values\"].HEART),reactsHooray:githubEdgeAddress(REACTS_TYPE,_graphqlTypes__WEBPACK_IMPORTED_MODULE_4__[\"ReactionContent$Values\"].HOORAY),reactsRocket:githubEdgeAddress(REACTS_TYPE,_graphqlTypes__WEBPACK_IMPORTED_MODULE_4__[\"ReactionContent$Values\"].ROCKET),correspondsToCommit:githubEdgeAddress(CORRESPONDS_TO_COMMIT_TYPE)});const createEdge=deep_freeze__WEBPACK_IMPORTED_MODULE_0___default()({authors:(author,content,timestampMs)=>({address:toRaw({type:AUTHORS_TYPE,author,content}),src:_nodes__WEBPACK_IMPORTED_MODULE_2__[\"toRaw\"](author),dst:_nodes__WEBPACK_IMPORTED_MODULE_2__[\"toRaw\"](content),timestampMs}),mergedAs:(pull,commit,timestampMs)=>({address:toRaw({type:MERGED_AS_TYPE,pull}),src:_nodes__WEBPACK_IMPORTED_MODULE_2__[\"toRaw\"](pull),dst:_nodes__WEBPACK_IMPORTED_MODULE_2__[\"toRaw\"](commit),timestampMs}),correspondsToCommit:(githubCommit,gitCommit,timestampMs)=>({address:toRaw({type:CORRESPONDS_TO_COMMIT_TYPE,githubCommit}),src:_nodes__WEBPACK_IMPORTED_MODULE_2__[\"toRaw\"](githubCommit),dst:_git_nodes__WEBPACK_IMPORTED_MODULE_3__[\"toRaw\"](gitCommit),timestampMs}),hasParent:(child,parent,timestampMs)=>({address:toRaw({type:HAS_PARENT_TYPE,child}),src:_nodes__WEBPACK_IMPORTED_MODULE_2__[\"toRaw\"](child),dst:_nodes__WEBPACK_IMPORTED_MODULE_2__[\"toRaw\"](parent),timestampMs}),references:(referrer,referent,timestampMs)=>({address:toRaw({type:REFERENCES_TYPE,referrer,referent}),src:_nodes__WEBPACK_IMPORTED_MODULE_2__[\"toRaw\"](referrer),dst:_nodes__WEBPACK_IMPORTED_MODULE_2__[\"toRaw\"](referent),timestampMs}),reacts:(reactionType,user,reactable,timestampMs)=>({address:toRaw({type:REACTS_TYPE,user,reactionType,reactable}),src:_nodes__WEBPACK_IMPORTED_MODULE_2__[\"toRaw\"](user),dst:_nodes__WEBPACK_IMPORTED_MODULE_2__[\"toRaw\"](reactable),timestampMs})});function lengthEncode(x){const parts=_core_graph__WEBPACK_IMPORTED_MODULE_1__[\"NodeAddress\"].toParts(x);return[String(parts.length),...parts];}function lengthDecode(x,fail){if(x.length===0){// Not length-encoded.\nthrow fail();}const[lengthString,...allParts]=x;const length=parseInt(lengthString,10);if(isNaN(length)){throw fail();}if(length>allParts.length){// Not enough elements.\nthrow fail();}return{parts:allParts.slice(0,length),rest:allParts.slice(length)};}function multiLengthDecode(x,fail){let remaining=x;let partses=[];while(remaining.length>0){const{parts,rest}=lengthDecode(remaining,fail);partses.push(parts);remaining=rest;}return partses;}function fromRaw(x){function fail(){return new Error(\"Bad address: \".concat(_core_graph__WEBPACK_IMPORTED_MODULE_1__[\"EdgeAddress\"].toString(x)));}if(!_core_graph__WEBPACK_IMPORTED_MODULE_1__[\"EdgeAddress\"].hasPrefix(x,GITHUB_PREFIX)){throw fail();}const[_unused_sc,_unused_gh,kind,...rest]=_core_graph__WEBPACK_IMPORTED_MODULE_1__[\"EdgeAddress\"].toParts(x);switch(kind){case AUTHORS_TYPE:{const parts=multiLengthDecode(rest,fail);if(parts.length!==2){throw fail();}const[authorParts,contentParts]=parts;const author=_nodes__WEBPACK_IMPORTED_MODULE_2__[\"fromRaw\"](_core_graph__WEBPACK_IMPORTED_MODULE_1__[\"NodeAddress\"].fromParts(authorParts));const content=_nodes__WEBPACK_IMPORTED_MODULE_2__[\"fromRaw\"](_core_graph__WEBPACK_IMPORTED_MODULE_1__[\"NodeAddress\"].fromParts(contentParts));return{type:AUTHORS_TYPE,author,content};}case MERGED_AS_TYPE:{const parts=multiLengthDecode(rest,fail);if(parts.length!==1){throw fail();}const[pullParts]=parts;const pull=_nodes__WEBPACK_IMPORTED_MODULE_2__[\"fromRaw\"](_core_graph__WEBPACK_IMPORTED_MODULE_1__[\"NodeAddress\"].fromParts(pullParts));return{type:MERGED_AS_TYPE,pull};}case HAS_PARENT_TYPE:{const parts=multiLengthDecode(rest,fail);if(parts.length!==1){throw fail();}const[childParts]=parts;const child=_nodes__WEBPACK_IMPORTED_MODULE_2__[\"fromRaw\"](_core_graph__WEBPACK_IMPORTED_MODULE_1__[\"NodeAddress\"].fromParts(childParts));return{type:HAS_PARENT_TYPE,child};}case REFERENCES_TYPE:{const parts=multiLengthDecode(rest,fail);if(parts.length!==2){throw fail();}const[referrerParts,referentParts]=parts;const referrer=_nodes__WEBPACK_IMPORTED_MODULE_2__[\"fromRaw\"](_core_graph__WEBPACK_IMPORTED_MODULE_1__[\"NodeAddress\"].fromParts(referrerParts));const referent=_nodes__WEBPACK_IMPORTED_MODULE_2__[\"fromRaw\"](_core_graph__WEBPACK_IMPORTED_MODULE_1__[\"NodeAddress\"].fromParts(referentParts));return{type:REFERENCES_TYPE,referrer,referent};}case REACTS_TYPE:{const[rawReactionType,...rest2]=rest;const reactionType=_graphqlTypes__WEBPACK_IMPORTED_MODULE_4__[\"ReactionContent$Values\"][rawReactionType];if(reactionType==null){throw fail();}const parts=multiLengthDecode(rest2,fail);if(parts.length!==2){throw fail();}const[userParts,reactableParts]=parts;const user=_nodes__WEBPACK_IMPORTED_MODULE_2__[\"fromRaw\"](_core_graph__WEBPACK_IMPORTED_MODULE_1__[\"NodeAddress\"].fromParts(userParts));const reactable=_nodes__WEBPACK_IMPORTED_MODULE_2__[\"fromRaw\"](_core_graph__WEBPACK_IMPORTED_MODULE_1__[\"NodeAddress\"].fromParts(reactableParts));return{type:REACTS_TYPE,reactionType,user,reactable};}default:throw fail();}}function toRaw(x){switch(x.type){case AUTHORS_TYPE:return _core_graph__WEBPACK_IMPORTED_MODULE_1__[\"EdgeAddress\"].append(Prefix.authors,...lengthEncode(_nodes__WEBPACK_IMPORTED_MODULE_2__[\"toRaw\"](x.author)),...lengthEncode(_nodes__WEBPACK_IMPORTED_MODULE_2__[\"toRaw\"](x.content)));case MERGED_AS_TYPE:return _core_graph__WEBPACK_IMPORTED_MODULE_1__[\"EdgeAddress\"].append(Prefix.mergedAs,...lengthEncode(_nodes__WEBPACK_IMPORTED_MODULE_2__[\"toRaw\"](x.pull)));case HAS_PARENT_TYPE:return _core_graph__WEBPACK_IMPORTED_MODULE_1__[\"EdgeAddress\"].append(Prefix.hasParent,...lengthEncode(_nodes__WEBPACK_IMPORTED_MODULE_2__[\"toRaw\"](x.child)));case REFERENCES_TYPE:return _core_graph__WEBPACK_IMPORTED_MODULE_1__[\"EdgeAddress\"].append(Prefix.references,...lengthEncode(_nodes__WEBPACK_IMPORTED_MODULE_2__[\"toRaw\"](x.referrer)),...lengthEncode(_nodes__WEBPACK_IMPORTED_MODULE_2__[\"toRaw\"](x.referent)));case REACTS_TYPE:return _core_graph__WEBPACK_IMPORTED_MODULE_1__[\"EdgeAddress\"].append(Prefix.reacts,x.reactionType,...lengthEncode(_nodes__WEBPACK_IMPORTED_MODULE_2__[\"toRaw\"](x.user)),...lengthEncode(_nodes__WEBPACK_IMPORTED_MODULE_2__[\"toRaw\"](x.reactable)));case CORRESPONDS_TO_COMMIT_TYPE:return _core_graph__WEBPACK_IMPORTED_MODULE_1__[\"EdgeAddress\"].append(Prefix.correspondsToCommit,...lengthEncode(_nodes__WEBPACK_IMPORTED_MODULE_2__[\"toRaw\"](x.githubCommit)));default:throw new Error(x.type);}}\n\n//# sourceURL=webpack:///./src/plugins/github/edges.js?");

/***/ }),

/***/ "./src/plugins/github/graphqlTypes.js":
/*!********************************************!*\
  !*** ./src/plugins/github/graphqlTypes.js ***!
  \********************************************/
/*! exports provided: PullRequestReviewState$Values, ReactionContent$Values */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PullRequestReviewState$Values\", function() { return PullRequestReviewState$Values; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ReactionContent$Values\", function() { return ReactionContent$Values; });\n/* harmony import */ var deep_freeze__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! deep-freeze */ \"deep-freeze\");\n/* harmony import */ var deep_freeze__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(deep_freeze__WEBPACK_IMPORTED_MODULE_0__);\n// Autogenerated file. Do not edit.\nconst PullRequestReviewState$Values=deep_freeze__WEBPACK_IMPORTED_MODULE_0___default()({APPROVED:\"APPROVED\",CHANGES_REQUESTED:\"CHANGES_REQUESTED\",COMMENTED:\"COMMENTED\",DISMISSED:\"DISMISSED\",PENDING:\"PENDING\"});const ReactionContent$Values=deep_freeze__WEBPACK_IMPORTED_MODULE_0___default()({CONFUSED:\"CONFUSED\",EYES:\"EYES\",HEART:\"HEART\",HOORAY:\"HOORAY\",LAUGH:\"LAUGH\",ROCKET:\"ROCKET\",THUMBS_DOWN:\"THUMBS_DOWN\",THUMBS_UP:\"THUMBS_UP\"});\n\n//# sourceURL=webpack:///./src/plugins/github/graphqlTypes.js?");

/***/ }),

/***/ "./src/plugins/github/nodes.js":
/*!*************************************!*\
  !*** ./src/plugins/github/nodes.js ***!
  \*************************************/
/*! exports provided: _githubAddress, REPO_TYPE, ISSUE_TYPE, PULL_TYPE, REVIEW_TYPE, COMMENT_TYPE, COMMIT_TYPE, USERLIKE_TYPE, USER_SUBTYPE, BOT_SUBTYPE, Prefix, loginAddress, fromRaw, toRaw */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"_githubAddress\", function() { return _githubAddress; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"REPO_TYPE\", function() { return REPO_TYPE; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ISSUE_TYPE\", function() { return ISSUE_TYPE; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PULL_TYPE\", function() { return PULL_TYPE; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"REVIEW_TYPE\", function() { return REVIEW_TYPE; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"COMMENT_TYPE\", function() { return COMMENT_TYPE; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"COMMIT_TYPE\", function() { return COMMIT_TYPE; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"USERLIKE_TYPE\", function() { return USERLIKE_TYPE; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"USER_SUBTYPE\", function() { return USER_SUBTYPE; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BOT_SUBTYPE\", function() { return BOT_SUBTYPE; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Prefix\", function() { return Prefix; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"loginAddress\", function() { return loginAddress; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fromRaw\", function() { return fromRaw; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"toRaw\", function() { return toRaw; });\n/* harmony import */ var deep_freeze__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! deep-freeze */ \"deep-freeze\");\n/* harmony import */ var deep_freeze__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(deep_freeze__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _core_graph__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../core/graph */ \"./src/core/graph.js\");\n/* harmony import */ var _bots__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./bots */ \"./src/plugins/github/bots.js\");\nconst GITHUB_PREFIX=_core_graph__WEBPACK_IMPORTED_MODULE_1__[\"NodeAddress\"].fromParts([\"sourcecred\",\"github\"]);function _githubAddress(){for(var _len=arguments.length,parts=new Array(_len),_key=0;_key<_len;_key++){parts[_key]=arguments[_key];}return _core_graph__WEBPACK_IMPORTED_MODULE_1__[\"NodeAddress\"].append(GITHUB_PREFIX,...parts);}const REPO_TYPE=\"REPO\";const ISSUE_TYPE=\"ISSUE\";const PULL_TYPE=\"PULL\";const REVIEW_TYPE=\"REVIEW\";const COMMENT_TYPE=\"COMMENT\";const COMMIT_TYPE=\"COMMIT\";const USERLIKE_TYPE=\"USERLIKE\";const USER_SUBTYPE=\"USER\";const BOT_SUBTYPE=\"BOT\";const Prefix=deep_freeze__WEBPACK_IMPORTED_MODULE_0___default()({base:GITHUB_PREFIX,repo:_githubAddress(REPO_TYPE),issue:_githubAddress(ISSUE_TYPE),pull:_githubAddress(PULL_TYPE),review:_githubAddress(REVIEW_TYPE),comment:_githubAddress(COMMENT_TYPE),commit:_githubAddress(COMMIT_TYPE),userlike:_githubAddress(USERLIKE_TYPE),user:_githubAddress(USERLIKE_TYPE,USER_SUBTYPE),bot:_githubAddress(USERLIKE_TYPE,BOT_SUBTYPE),reviewComment:_githubAddress(COMMENT_TYPE,REVIEW_TYPE),issueComment:_githubAddress(COMMENT_TYPE,ISSUE_TYPE),pullComment:_githubAddress(COMMENT_TYPE,PULL_TYPE)});/**\n * Return the address corresponding to a GitHub login.\n *\n * If the login is considered a bot, then a bot address is returned. Otherwise,\n * a regular user address is returned. The method does not attempt to find out\n * whether the address should actually be an organization address, as we don't\n * yet handle organization addresses.\n *\n * Note: The signature will need to be refactored when we make the list of bots\n * a configuration option rather than a hardcoded constant.\n */function loginAddress(username){const bots=Object(_bots__WEBPACK_IMPORTED_MODULE_2__[\"botSet\"])();if(bots.has(username)){return _core_graph__WEBPACK_IMPORTED_MODULE_1__[\"NodeAddress\"].append(Prefix.bot,username);}else{return _core_graph__WEBPACK_IMPORTED_MODULE_1__[\"NodeAddress\"].append(Prefix.user,username);}}// Verify that Commentable is a subtype of Parent\nconst _unused_static=_=>_;function fromRaw(x){function fail(){return new Error(\"Bad address: \".concat(_core_graph__WEBPACK_IMPORTED_MODULE_1__[\"NodeAddress\"].toString(x)));}if(!_core_graph__WEBPACK_IMPORTED_MODULE_1__[\"NodeAddress\"].hasPrefix(x,GITHUB_PREFIX)){throw fail();}const[_unused_sc,_unused_gh,kind,...rest]=_core_graph__WEBPACK_IMPORTED_MODULE_1__[\"NodeAddress\"].toParts(x);switch(kind){case REPO_TYPE:{if(rest.length!==2){throw fail();}const[owner,name]=rest;return{type:REPO_TYPE,owner,name};}case ISSUE_TYPE:{if(rest.length!==3){throw fail();}const[owner,name,number]=rest;const repo={type:REPO_TYPE,owner,name};return{type:ISSUE_TYPE,repo,number};}case PULL_TYPE:{if(rest.length!==3){throw fail();}const[owner,name,number]=rest;const repo={type:REPO_TYPE,owner,name};return{type:PULL_TYPE,repo,number};}case REVIEW_TYPE:{if(rest.length!==4){throw fail();}const[owner,name,pullNumber,id]=rest;const repo={type:REPO_TYPE,owner,name};const pull={type:PULL_TYPE,repo,number:pullNumber};return{type:REVIEW_TYPE,pull,id};}case COMMENT_TYPE:{if(rest.length<1){throw fail();}const[subkind,...subrest]=rest;switch(subkind){case ISSUE_TYPE:{if(subrest.length!==4){throw fail();}const[owner,name,issueNumber,id]=subrest;const repo={type:REPO_TYPE,owner,name};const issue={type:ISSUE_TYPE,repo,number:issueNumber};return{type:COMMENT_TYPE,parent:issue,id};}case PULL_TYPE:{if(subrest.length!==4){throw fail();}const[owner,name,pullNumber,id]=subrest;const repo={type:REPO_TYPE,owner,name};const pull={type:PULL_TYPE,repo,number:pullNumber};return{type:COMMENT_TYPE,parent:pull,id};}case REVIEW_TYPE:{if(subrest.length!==5){throw fail();}const[owner,name,pullNumber,reviewFragment,id]=subrest;const repo={type:REPO_TYPE,owner,name};const pull={type:PULL_TYPE,repo,number:pullNumber};const review={type:REVIEW_TYPE,pull,id:reviewFragment};return{type:COMMENT_TYPE,parent:review,id};}default:throw fail();}}case COMMIT_TYPE:{if(rest.length!==1){throw fail();}const[id]=rest;return{type:COMMIT_TYPE,id};}case USERLIKE_TYPE:{if(rest.length!==2){throw fail();}const[subtype,login]=rest;if(subtype!==\"USER\"&&subtype!==\"BOT\"){throw fail();}return{type:USERLIKE_TYPE,subtype,login};}default:throw fail();}}function toRaw(x){switch(x.type){case REPO_TYPE:return _core_graph__WEBPACK_IMPORTED_MODULE_1__[\"NodeAddress\"].append(Prefix.repo,x.owner,x.name);case ISSUE_TYPE:return _core_graph__WEBPACK_IMPORTED_MODULE_1__[\"NodeAddress\"].append(Prefix.issue,x.repo.owner,x.repo.name,x.number);case PULL_TYPE:return _core_graph__WEBPACK_IMPORTED_MODULE_1__[\"NodeAddress\"].append(Prefix.pull,x.repo.owner,x.repo.name,x.number);case REVIEW_TYPE:return _core_graph__WEBPACK_IMPORTED_MODULE_1__[\"NodeAddress\"].append(Prefix.review,x.pull.repo.owner,x.pull.repo.name,x.pull.number,x.id);case COMMENT_TYPE:switch(x.parent.type){case ISSUE_TYPE:return _core_graph__WEBPACK_IMPORTED_MODULE_1__[\"NodeAddress\"].append(Prefix.issueComment,x.parent.repo.owner,x.parent.repo.name,x.parent.number,x.id);case PULL_TYPE:return _core_graph__WEBPACK_IMPORTED_MODULE_1__[\"NodeAddress\"].append(Prefix.pullComment,x.parent.repo.owner,x.parent.repo.name,x.parent.number,x.id);case REVIEW_TYPE:return _core_graph__WEBPACK_IMPORTED_MODULE_1__[\"NodeAddress\"].append(Prefix.reviewComment,x.parent.pull.repo.owner,x.parent.pull.repo.name,x.parent.pull.number,x.parent.id,x.id);default:throw new Error(\"Bad comment parent type: \".concat(x.parent.type));}case USERLIKE_TYPE:switch(x.subtype){case\"BOT\":return _core_graph__WEBPACK_IMPORTED_MODULE_1__[\"NodeAddress\"].append(Prefix.bot,x.login);case\"USER\":return _core_graph__WEBPACK_IMPORTED_MODULE_1__[\"NodeAddress\"].append(Prefix.user,x.login);default:throw new Error(x.subtype);}case COMMIT_TYPE:return _core_graph__WEBPACK_IMPORTED_MODULE_1__[\"NodeAddress\"].append(Prefix.commit,x.id);default:throw new Error(\"Unexpected type \".concat(x.type));}}\n\n//# sourceURL=webpack:///./src/plugins/github/nodes.js?");

/***/ }),

/***/ "./src/util/compat.js":
/*!****************************!*\
  !*** ./src/util/compat.js ***!
  \****************************/
/*! exports provided: toCompat, fromCompat */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"toCompat\", function() { return toCompat; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fromCompat\", function() { return fromCompat; });\nfunction toCompat(compatInfo,obj){return[compatInfo,obj];}/**\n * Load an object from compatibilized state created by `toCompat`.\n * The object has an expected type and version, and may optionally have\n * handler functions for transforming previous versions into a canonical state.\n * If a handler is present for the current version, it will be applied.\n * Throws an error if the compatibilized object is the wrong type, or if its version\n * is not current and there was no handler for its version.\n */function fromCompat(expectedCompatInfo,obj,handlers){if(!Array.isArray(obj)||obj.length!==2){throw new Error(\"Tried to load object that didn't have compatibility defined\");}const{type,version}=obj[0];let result=obj[1];const{type:expectedType,version:expectedVersion}=expectedCompatInfo;if(type!==expectedType){throw new Error(\"Expected type to be \".concat(expectedType,\" but got \").concat(type));}if(handlers!=null&&handlers[version]!=null){result=handlers[version](result);}else if(version!==expectedVersion){throw new Error(\"\".concat(type,\": tried to load unsupported version \").concat(version));}return result;}\n\n//# sourceURL=webpack:///./src/util/compat.js?");

/***/ }),

/***/ "./src/util/dedent.js":
/*!****************************!*\
  !*** ./src/util/dedent.js ***!
  \****************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return dedent; });\n/*\n * A template tag function that performs dedenting on the template, but\n * not its arguments.\n *\n * For instance, given the template\n *\n *     |dedent`\\\n *     |    one ${one}\n *     |        two ${two}\n *     |    done`,\n *\n * where `one === \"1\"` and `two === \"\\n    2\"`, the template string\n * would expand to \"one 1\\n    two\\n    2\\ndone\". Note that four spaces\n * of indentation were stripped off of each of \"one\" and \"two\", but not\n * from \"2\".\n *\n * Lines that contain only whitespace are not used for measuring.\n */function dedent(strings){const lineLengths=strings.join(\"\").split(\"\\n\").filter(line=>line.trim().length!==0).map(line=>line.length-line.trimLeft().length);const trimAmount=Math.min.apply(null,lineLengths);const parts=[];for(let i=0;i<strings.length;i++){const trimmed=strings[i].split(\"\\n\").map((line,j)=>i===0||j>0?line.substr(trimAmount):line).join(\"\\n\");parts.push(trimmed);if(i<(arguments.length<=1?0:arguments.length-1)){parts.push(i+1<1||arguments.length<=i+1?undefined:arguments[i+1]);}}return parts.join(\"\");}\n\n//# sourceURL=webpack:///./src/util/dedent.js?");

/***/ }),

/***/ "./src/util/map.js":
/*!*************************!*\
  !*** ./src/util/map.js ***!
  \*************************/
/*! exports provided: toObject, fromObject, copy, mapKeys, mapValues, mapEntries, merge, pushValue */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"toObject\", function() { return toObject; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fromObject\", function() { return fromObject; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"copy\", function() { return copy; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"mapKeys\", function() { return mapKeys; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"mapValues\", function() { return mapValues; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"mapEntries\", function() { return mapEntries; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"merge\", function() { return merge; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"pushValue\", function() { return pushValue; });\n/**\n * Convert a string-keyed map to an object. Useful for conversion to\n * JSON. If a map's keys are not strings, consider invoking `mapKeys`\n * first.\n */function toObject(map){const result={};for(const[k,v]of map.entries()){result[k]=v;}return result;}/**\n * Convert an object to a map. The resulting map will have key-value\n * pairs corresponding to the enumerable own properties of the object in\n * iteration order, as returned by `Object.keys`.\n */function fromObject(object){const result=new Map();const keys=Object.keys(object);for(const key of keys){result.set(key,object[key]);}return result;}/**\n * Shallow-copy a map, allowing upcasting its type parameters.\n *\n * The `Map` type constructor is not covariant in its type parameters,\n * which means that (e.g.) `Map<string, Dog>` is not a subtype of\n * `Map<string, Animal>` even if `Dog` is a subtype of `Animal`. This is\n * because, given a `Map<string, Animal>`, one can insert a `Cat`, which\n * would break invariants of existing references to the variable as a\n * map containing only `Dog`s.\n *\n *     declare class Animal {};\n *     declare class Dog extends Animal {};\n *     declare class Cat extends Animal {};\n *     declare var dogMap: Map<string, Dog>;\n *     const animalMap: Map<string, Animal> = dogMap;  // must fail\n *     animalMap.set(\"tabby\", new Cat());  // or we could do this...\n *     (dogMap.values(): Iterator<Dog>);  // ...now contains a `Cat`!\n *\n * This problem only exists when a map with existing references is\n * mutated. Therefore, when we shallow-copy a map, we have the\n * opportunity to upcast its type parameters: `copy(dogMap)` _can_ be a\n * `Map<string, Animal>`.\n */function copy(map){const entries=map.entries();return new Map(entries);}/**\n * Map across the keys of a map. Note that the key-mapping function is\n * provided both the key and the value for each entry.\n *\n * The key-mapping function must be injective on the map's key set. If\n * it maps two distinct input keys to the same output key, an error may\n * be thrown.\n */function mapKeys(map,f){const result=new Map();for(const[k,v]of map.entries()){const outK=f(k,v);if(result.has(outK)){throw new Error(\"duplicate key: \"+String(outK));}result.set(outK,v);}return result;}/**\n * Map across the values of a map. Note that the value-mapping function\n * is provided both the key and the value for each entry.\n *\n * There are no restrictions on the value-mapping function (in\n * particular, it need not be injective).\n */function mapValues(map,g){const result=new Map();for(const[k,v]of map.entries()){result.set(k,g(k,v));}return result;}/**\n * Map simultaneously across the keys and values of a map.\n *\n * The key-mapping function must be injective on the map's key set. If\n * it maps two distinct input keys to the same output key, an error may\n * be thrown. There are no such restrictions on the value-mapping\n * function.\n */function mapEntries(map,h){const result=new Map();for(const[k,v]of map.entries()){const[outK,outV]=h(k,v);if(result.has(outK)){throw new Error(\"duplicate key: \"+String(outK));}result.set(outK,outV);}return result;}/**\n * Merge maps without mutating the arguments.\n *\n * Merges multiple maps, returning a new map which has every key from\n * the source maps, with their corresponding values. None of the inputs\n * are mutated. In the event that multiple maps have the same key, an\n * error will be thrown.\n */function merge(maps){const result=new Map();let updates=0;for(const map of maps){for(const[key,value]of map.entries()){result.set(key,value);if(result.size!==++updates){throw new Error(\"Maps have duplicate key: \".concat(String(key)));}}}return result;}/**\n * Given a map whose values are arrays, push an element onto the array\n * corresponding to the given key. If the key is not in the map, first\n * insert it with value a new empty array.\n *\n * If the key is already in the map, its value will be mutated, not\n * replaced.\n */function pushValue(map,key,value){let arr=map.get(key);if(arr==null){map.set(key,arr=[]);}arr.push(value);return arr;}\n\n//# sourceURL=webpack:///./src/util/map.js?");

/***/ }),

/***/ "./src/util/null.js":
/*!**************************!*\
  !*** ./src/util/null.js ***!
  \**************************/
/*! exports provided: map, get, orThrow, orElse, filterList */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"map\", function() { return map; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"get\", function() { return get; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"orThrow\", function() { return orThrow; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"orElse\", function() { return orElse; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"filterList\", function() { return filterList; });\n/**\n * Utilities for working with nullable types: `?T = T | null | void`.\n *\n * These functions use the native runtime representation, as opposed to\n * creating an `Optional<T>` wrapper class. This ensures that they have\n * minimal runtime cost (just a function call), and that they are\n * trivially interoperable with other code.\n *\n * When a value of type `?T` is `null` or `undefined`, we say that it is\n * _absent_. Otherwise, it is _present_.\n *\n * Some functions that typically appear in such libraries are not\n * needed:\n *\n *   - `join` (`??T => ?T`) can be implemented as the identity function,\n *     because the Flow types `??T` and `?T` are equivalent;\n *   - `flatMap` (`?T => (T => ?U) => ?U`) can be implemented simply as\n *     `map`, again because `??T` and `?T` are equivalent;\n *   - `first` (`?T => ?T => ?T`) can be implemented simply as `orElse`,\n *     again because `??T` and `?T` are equivalent;\n *   - `isPresent` (`?T => boolean`) doesn't provide much value over the\n *     equivalent abstract disequality check;\n *   - constructors like `empty` (`() => ?T`) and `of` (`T => ?T`) are\n *     entirely spurious.\n *\n * Other functions could reasonably be implemented, but have been left\n * out because they have rarely been needed:\n *\n *   - `filter` (`?T => (T => boolean) => ?T`);\n *   - `forEach` (`?T => (T => void) => void`);\n *   - `orElseGet` (`?T => (() => T) => T`), which is useful in the case\n *      where constructing the default value is expensive.\n *\n * (Of these three, `orElseGet` would probably be the most useful for\n * our existing codebase.)\n */ /**\n * Apply the given function inside the nullable. If the input is absent,\n * then it will be returned unchanged. Otherwise, the given function\n * will be applied.\n */function map(x,f){return x!=null?f(x):x;}/**\n * Extract the value from a nullable. If the input is present, it will\n * be returned. Otherwise, an error will be thrown with the provided\n * message (defaulting to the string representation of the absent input).\n */function get(x,errorMessage){if(x==null){throw new Error(errorMessage!=null?errorMessage:String(x));}else{return x;}}/**\n * Extract the value from a nullable. If the input is present, it will\n * be returned. Otherwise, an error will be thrown, with message given\n * by the provided function.\n */function orThrow(x,getErrorMessage){if(x==null){throw new Error(getErrorMessage());}else{return x;}}/**\n * Extract the value from a nullable, using the provided default value\n * in case the input is absent.\n */function orElse(x,defaultValue){return x!=null?x:defaultValue;}/**\n * Filter nulls and undefined out of an array, returning a new array.\n *\n * The functionality is easy to implement without a util method (just call\n * `filter`); however Flow doesn't infer the type of the output array based on\n * the callback that was passed to filter. This method basically wraps filter\n * in a type-aware way.\n */function filterList(xs){// A type-safe way to implement this would be:\n/*:: (xs.flatMap((x) => x == null ? [] : [x]): T[]); */ // For performance, we instead take an unsafe route.\nreturn xs.filter(x=>x!=null);}\n\n//# sourceURL=webpack:///./src/util/null.js?");

/***/ }),

/***/ "d3-array":
/*!***************************!*\
  !*** external "d3-array" ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"d3-array\");\n\n//# sourceURL=webpack:///external_%22d3-array%22?");

/***/ }),

/***/ "d3-time":
/*!**************************!*\
  !*** external "d3-time" ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"d3-time\");\n\n//# sourceURL=webpack:///external_%22d3-time%22?");

/***/ }),

/***/ "deep-freeze":
/*!******************************!*\
  !*** external "deep-freeze" ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"deep-freeze\");\n\n//# sourceURL=webpack:///external_%22deep-freeze%22?");

/***/ }),

/***/ "json-stable-stringify":
/*!****************************************!*\
  !*** external "json-stable-stringify" ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"json-stable-stringify\");\n\n//# sourceURL=webpack:///external_%22json-stable-stringify%22?");

/***/ }),

/***/ "lodash.isequal":
/*!*********************************!*\
  !*** external "lodash.isequal" ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"lodash.isequal\");\n\n//# sourceURL=webpack:///external_%22lodash.isequal%22?");

/***/ }),

/***/ "lodash.sortby":
/*!********************************!*\
  !*** external "lodash.sortby" ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"lodash.sortby\");\n\n//# sourceURL=webpack:///external_%22lodash.sortby%22?");

/***/ })

/******/ });
});